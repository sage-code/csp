<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Lear basic concepts about functions in Python.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, python, programming, function, switch">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Python Functions</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="../prism.css">
  <script src="../prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">

<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col bottom-right" align="right">
        <a href="index.html#py-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>

<h2>Python Functions</h2>

<div class="alert alert-secondary shadow-sm">A function is a block of code that make a computation and return a result. If a block of code do not have a name or do not return a result it is not a function.This kind of block can be considered method, subroutine or maybe procedure. That is: the role of each block is establish by it's context.
</div>

<div align="center">
  <img src="../images/function.jpg" alt="continue" srcset="../images/function.svg" width="520" class="img-fluid protect rounded shadow border" >
  <p>Function Concepts</p>
</div>
<hr>

<h4>Page Bookarks</h4>
<hr>
<nav><ul>
    <li><a href="#declaration">Declaration</a></li>
    <li><a href="#result">Result</a></li>
    <li><a href="#params">Parameters</a></li>
    <li><a href="#namespace">Namespace</a></li>
    <li><a href="#attributes">Attributes</a></li>
    <li><a href="#varargs">Variable Arguments</a> </li>
    <li><a href="#switch">Switch Function</a></li>
    <li><a href="#closures">Closures</a></li>
    <li><a href="#generators">Generators</a></li>
</ul></nav>
<hr>

<h2 id="declaration">Declaration</h2>

<p>In Python we use keyword <em>"def"</em> to define a named block of code. This block can be reused to calculate one or more values called results. The result value is defined using keyword <em>"return".</em>If a block of code look like a function but do not return any value, then is not a function but something else.
</p>

<h4>Example:</h4>
<p>In this example we define a block of code named "fib" that have a side-effect but does not return a result:This block of code is very similar to a function but is in fact a subprogram.That is: python do not use specific keywords like: "function", "procedure" or "method" but only "def".
</p>

<pre><code class="language-python line-numbers">
# create a function fib with parameter n
def fib(n):
     """Print a Fibonacci series up to n."""
     a, b = 0, 1
     while a &lt; n:
         print(a, end=' ')
         a, b = b, a+b
     print()
pass # end fib

fib(2000) #call function fib
</code></pre>

<h4>Output</h4>

<pre><code class="language-output">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</code></pre>

<p><b>Homework:</b> Test this example live:
<a href="https://repl.it/@elucian/python-fibonacci" target="_blank" rel="noopener noreferrer">Fibonacci</a></p>

<p><b>Note:</b> Remember in Python the indentation is mandatory. A named block end when the indentation is back align with "def" keyword.In the example above, I have used keyword "pass" to make a "null statement" to mark the end of block.This style of programming is optional. Statement "pass" can be used to mark the end of any block of code.
</p>

<p><b>Add Description</b></p>
<p>The description of a function can be created using triple quotes and string as the first statement after the function declaration. This can be used to find information about function using: help(&lt;function_name&gt;)</p>

<h2 id="result">The Result</h2>
<p>Functions usually produce a result that can be captured into a variable using assign operator "=". It can also be used in expressions. In the example below we calculate a mathematical function: "f(n) = !n" (factorial) using a recursive function call. That is a function that call itself with different parameters until a condition becomes True:</p>

<h4>Example:</h4>

<pre><code class="language-python line-numbers">
# calculate factorial of n
def factorial(n):
    if n==0:
         return 1
    else:
         return n*factorial(n-1)

# call factorial function and capture result
result=factorial(5)
print(result)
</code></pre>

<h2 id="params">Parameters</h2>

<p>Function parameters, sometimes called "formal parameters" are actually local variables that can receive values from a function call. Parameters can be mandatory or optional. Mandatory parameters are usually declared first. Optional parameters, have a "default value" specified in parameter declaration using notation: <code>"param = value" or "param:type = value.</code></p>

<p><b>Mandatory arguments</b></p><p>To execute a function we use function name follow by a list of arguments enclosed in round brackets and separated by comma like: <code>function_name(args).</code> The parenthesis are mandatory after the function name, otherwise the function is not executed.If a function has mandatory parameters, for each parameter we must provide and argument. The argument can be a value, a variable or an expression.
</p>

<p><b>Optional arguments</b></p>

<p>Arguments are paired-up with parameters by position or by name using equal sign. Mandatory and optional arguments can coexist in a call. For mandatory parameters we can assign arguments by position while optional parameters can receive arguments by name. We can also use names for all arguments, but this is unusual practice.</p>

<h4>Example:</h4>

<p>Next example is using what you have learned so far to create a median function. This function is good only for 2 up to 5 numbers. It also has a logical defect to establish the divisor in case of zero value arguments.</p>

<pre><code class="language-python line-numbers">
# define function with variable argument
def avg(a,b,c=0,d=0,e=0):
    divisor = 2
    if c != 0: divisor += 1;
    if d != 0: divisor += 1;
    if e != 0: divisor += 1;
    result = (a+b+c+d+e)/divisor;
    return result

# test function avg
print (avg(2,4)); # 3.0
print (avg(0,5,10)); # 5.0
print (avg(0,0,e=9)); # 3.0
print (avg(1,0,d=10,e=20)); #7.75
</code></pre>

<p><b>Homework:&nbsp;</b>Copy the example from here:
<a href="https://repl.it/@elucian/python-optional" target="_blank" rel="noopener noreferrer">optional</a> and then make a better version using variable argument "varargs", that you will learn later in this article. Post your snippet on Discord or make a Gist on GitHub and brag about it on reddit.I will give you one reputation point for this job.</p>

<h2 id="varargs">Variable arguments</h2>

<p>A procedure can receive a list of arguments into one special parameter. This feature is sometimes called: "varargs" or "rest". For declaring this parameter we use prefix "*". This parameter becomes a collection of values visible in local scope.&nbsp;</p>
<h4>Example:</h4>
<pre><code class="language-python line-numbers">
# define function with variable argument
def sum_all(first:int, *rest: [int]) -&gt; int:
    result: int = first
    for e in rest:
        result += e
    return result

# test function sum_all
print (sum_all(0)); # 0
print (sum_all(1,2)); # 3
print (sum_all(1,2,3)); # 6

# combine with spread operator
args = [1,1,1]
print (sum_all(*args)); # 3
</code></pre>

<p><b>Homework:</b> Test this snippet on-line:
<a href="https://repl.it/@elucian/python-varargs" target="_blank" rel="noopener noreferrer">Varargs</a></p>

<p><b>Note:</b> In the example above I have used a new syntax available since Python 3.6, that enables you to specify parameters types, variable types and function result type. This may surprise you since you know, Python is a dynamic language. It is a good practice to use this style of programming.</p>

<p>Type hinting may improve program readability but does not affect performance. It was introduced to improve programming experience for developers. Python can use type hinting to avoid logical mistakes for large projects.</p>

<h2 id="namespace">Namespace</h2>

<p>A namespace is a composite word from "name" and "space". It represents a block of code that hold several identifiers. A namespace is defined by a "scope". This is a region of a program used to define: variables, constants and functions.</p>

<h4>Example:</h4>
<pre><code class="language-python line-numbers">
# define large namespace
def scope_test():
    # local scope
    def do_local():
        spam = "local spam"
    pass # end do_local

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"
    pass # end do_nonlocal

    def do_global():
        global spam
        spam = "global spam"
    pass # end do_global

    # back to namespace
    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)
pass # end scope_test

# back to global scope
scope_test() # test function with no result
print("In global scope:", spam)
</code></pre>

<p>Test this example live:
<a href="https://repl.it/@elucian/python-namespaces" target="_blank" rel="noopener noreferrer">Namespaces</a></p>

<p><b>Output of the program:</b></p>

<pre><code class="language-output">
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
</code></pre>

<p><b>Note:</b> The namespaces are nested. The outermost scope is called "global" scope and it create a "global" namespace. Functions can be nested. Inside every function there is a local namespace.</p>

<p><b>Shadowing:</b></p>

<p>Using "=" will create a new variable in the local scope. If a variable exists already defined in the global scope or in the parent scope it is shadowed. We create a new variable in the local scope that hide the outer scope variable. To avoid shadowing we have to declare variables using <b><em>"global"</em></b> or <b><em>"nonlocal"</em></b> keywords.This is necessary for every single nested function that uses other variables than the local variables.</p>

<h2 id="attributes">Function attributes</h2>

<p>In Python a function is an object. Any object can have attributes that can be created using a dot operator. Function attributes are attached to the function as static variables. This is another alternative to global variables and it can be used to create encapsulated functions that behave like objects.</p>

<h4>Example:</h4>
<p>In the next example the function test_attr() is creating an&nbsp;attribute called <em>counter</em>&nbsp;the first time is called. Then the attribute is used to memorize the current counter value. Next time is able to return the&nbsp;value and increment it for next call.</p>

<pre><code class="language-python line-numbers">
# demonstrate attributes attached to a function
def test_attr():
    if not hasattr(test_attr, "counter"):
        test_attr.counter = 0
    else:
        test_attr.counter += 1
    return test_attr.counter
pass # end test_attr

# call function  attributes
def main():
    for i in range(0,10):
        j=test_attr()
        print(i,'-&gt;',j)
pass # end main

# compiler entry point
if __name__ == "__main__":
    main()
pass # end if
</code></pre>

<p><b>Homework:</b> Open test this example live: <a href="https://repl.it/@elucian/python-function-attributes">Attributes</a></p>
<p><b>Test output:</b></p>

<pre><code class="language-output">
0 -&gt; 0
1 -&gt; 1
2 -&gt; 2
3 -&gt; 3
4 -&gt; 4
5 -&gt; 5
6 -&gt; 6
7 -&gt; 7
8 -&gt; 8
9 -&gt; 9
</code></pre>

<h2 id="switch">Switch function:</h2>

<p class="alert alert-danger">Switch statement does not exist in Python.However you can simulate a switch statement using different techniques. In the next example we create a fake statement <em><b>switch </b></em>using two functions:</p>

<pre><code class="language-python line-numbers">
#define a value holder function
# =&gt; True
def switch(value):
    switch.value=value
    return True

#define matching case function
# =&gt; True or False
def case(*args):
    return any((arg == switch.value for arg in args))

# Switch example:
print("Describe a number from range:")
for n in range(0,10):
  print(n, end=",")
print(flush=True)

# Ask for a number and analyze
x=input("n:")
n=int(x)
while switch(n):
    if case(0):
        print ("n is zero;")
        break
    if case(1, 4, 9):
        print ("n is a perfect square;")
        break
    if case(2):
        print ("n is an even number;")
    if case(2, 3, 5, 7):
        print ("n is a prime number;")
        break
    if case(6, 8):
        print ("n is an even number;")
        break
    print ("Only single-digit numbers are allowed.")
pass # end of switch
</code></pre>

<h3>Example description</h3>

<p><b>switch</b>: In the example above I use one function "switch" with attribute "value" and one function "case" that return True or False if "switch.value" is one of arguments.</p>

<p><b>case:</b> Is a function that receive a variable number of arguments. This function uses any(...), a Python function that returns True if any item in an <em>iterable object</em> is True, otherwise it returns False. If the iterable object is empty, the any() function will return False. </p>

<p><b>while:</b> Using while loop will iterate one single time ant we can use break statement like a "switch" statement will do. This example demonstrate how using meaningful names for functions python language can be extended in interesting ways.</p>

<p><b>print: </b>This example also demonstrate how to use print function to print numbers and avoid new line using optional parameter end=",".</p>

<h3>Testing the program</h3>

<p>Open this example live and run it: <a href="https://repl.it/@elucian/python-switch-function" target="_blank" rel="noopener noreferrer">switch function</a></p>
<pre><code class="language-python line-numbers">
Describe a number from range:
0,1,2,3,4,5,6,7,8,9,
n:3
n is a prime number;

Process finished with exit code 0
</code></pre>


<h2 id="closures">Python Closures</h2>

<div class="alert alert-secondary shadow-sm">
Closure is a higher order function that encapsulate one or several other functions. The enclosed functions have access to variables used when the function was created. This is called "context".Using closures is a high appreciated skill that can improve performance of your applications.
</div>

<p>Python can be used as a functional programming language. In Python you can create functions that will produce as a result another function. That technique is useful to create light-weight code without using object oriented programming.</p>

<h4>Example:</h4>
<p>Next example is a function that create another function called "test_closure"</p>

<pre><code class="language-python line-numbers">
# Create a closure
def test_closure(max):
    index = {1:-1} # mutable attribute
    def enclosed():
        if index[1] &lt;= max:
           index[1] += 1
           return index[1]
        else:
           return -1
    return enclosed

def main():
    # use closure based function my_scan()
    my_scan = test_closure(5);
    for i in range(0,5):
        print(i,'-&gt;',my_scan())

# program entry point
if __name__ == "__main__":
    main()
</code></pre>
    
<p><b>Note:</b> In python <em>context variables</em> are read only. However there is a workaround to help resolve this issue: You can use a dictionary or a list with a single element. The elements enclosed into any container can be read and write. In the example, <em><span style="text-decoration: underline;">index</span></em> is a mutable attribute. Nice trick isn't it?</p>

<h2>Using Closure</h2>

<p>We use closure like a <em>poor man class</em> to generate <em>function instances</em>. This is the secret, we encapsulate one or several states with the closer function. This is helping to create similar functions at runtime based on different parameter values that can hold a <em>state</em>. Closures can help to avoid polluting the global scope with variables that can become hard to track.</p>

<p><b>test_closure(max)<br /></b></p>

<p>In the example above function test_closure is a closure function because it returns a function <em>enclosed.</em>This function is captured using closure invocation: my_scan = test_closure(5);</p>

<p><b>my_scan()</b></p>
<p>Function my_scan is a function instance because it was created out of enclosure at runtime. Once instantiated my_scan function can be used like any other function. It is like a generator. Returns next number each time is called up to 5 then will return -1.</p>

<pre class="language-output">
0 -&gt; 0
1 -&gt; 1
2 -&gt; 2
3 -&gt; 3
4 -&gt; 4
</pre>

<p><b>Homework:</b> Try to run this example live: <a href="https://repl.it/@elucian/python-closure">python closure</a></p>

<hr>

<h2 id="generators">Python Generators</h2>

<div class="alert alert-secondary shadow-sm">The generator is a special function that do not terminate after returning a result. Instead it's instance is suspended in memory for a while until the last result is created. Think about it like a resumable function.This construct is very common in Python and is used for performance.
</div>

<h4>Example:</h4>
<p>In this example we create a function that generate integer numbers:</p>

<pre><code class="language-python line-numbers">
#Create a generator
def test_generator(p_stop):
    counter = 0
    while counter &lt;= p_stop:
       yield counter
       counter +=1

def main():
    # example generator:"aindex"
    print("call generator using loop")
    aindex = test_generator(3)
    for i in aindex:
        print("i=%d" % i)

    # example generator:"bindex"
    print("call generator using next")
    bindex = test_generator(3)
    print("y=%d" % next(bindex))
    print("y=%d" % next(bindex))

# compiler entry point
if __name__ == "__main__":
    main()
</code></pre>

<p>This will print:</p>

<pre><code class="language-output">
call generator using loop
i=0
i=1
i=2
i=3
call generator using next
y=0
y=1
</code></pre>

<p><b>Homework: </b>Open this example live and run it: <a href="https://repl.it/@elucian/python-generator" target="_blank" rel="noopener noreferrer">generator</a></p>

<h4>test_generator</h4>
<p>The function generator is test_generator(). This is a resumable function that will stay in memory and wait for next() to be invoked. When the last element is generated the function terminate. A generator function is a "high order function" and must be instantiated with a parameter.</p>

<h4>aindex</h4>
<p>I have created 2 generators using the same function. First generator "aindex" is used into a loop like an iterable collection. Not all values are generated in memory but one by one. This is very efficient.</p>

<h4>bindex</h4>
<p>Second generator bindex = test_generator(3).For this generator I have used next(bindex) to create 2 values (0, 1). Evert time next() is invoked a new value is created. The third value is never used therefore "bindex" generator do not reach the end until program termination.</p>

<h4>keyword "yield"</h4>
<p>Keyword yield is specific to generators. This is like return, except the function do not terminate. Instead the execution is suspended and resumed using next().</p>

<hr>

<p><b>Read next:</b> <a href="classes.html">Classes</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>


</div>


</body>
</html>