<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Composite data types in C programming language.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="C, array, data, types">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>C Composite Types</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="https://sagecode.net/prism.css">
  <script src="https://sagecode.net/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>  
    <div class="col  bottom-right">
        <a href="index.html#c-lang" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>


<h1>C Composite Types</h1>

<div class="alert alert-secondary shadow-sm">
<p>Composite data types are user defined data types that consist of several elements grouped together. Usually data elements are stored close together in consecutive memory addresses.</p>
</div>

<p>There are several composite data types in C.</p>
<ul>
<li>Arrays</li>
<li>Strings</li>
<li>Structures</li>
<li>Unions</li>
</ul>

<h2>Arrays</h2>

<p>This composite data type is a group of multiple elements. All elements have same data type and are ordered by a numeric index (i &ge; 0). The elements in the array can be identified using array name and index enclosed in square brackets: array[i]. First element is array[0].</p>

<div align="center">
  <img src="../images/array.jpg" alt="array" srcset="../images/array.svg" width="520" class="img-fluid protect rounded shadow border" >    
  <p>Array Elements</p>
</div>  

<h4>Syntax:</h4>
<p>element_type identifier[size];</p>
<h4>Example:</h4>
<pre><code class="language-c line-numbers">#include &lt;stdio.h&gt;
int main () {
    /* define array with 10 integer elements */
    int a[10] = {0};
    /* array initialization */
    for (int i = 0; i &lt; 10; i++ ) {
        a[i] = i;
    }
    /* array traversal and print */
    for (int i = 0; i &lt; 10; i++ ) {
        printf("a[%d] = %d\n", i, a[i] );
    }
    return 0;
}</code></pre>

<h2>Strings</h2>

<p>We can define string literals in C using double quotes: "&hellip;". However a string variable must be defined as an array of characters. Each element of a string can be identified by variable name and its index. Last element in a string is NUL character: "\0".</p>
<h4>Syntax:</h4>
<p>char string_name[capacity+1] = "content";</p>
<h4>Example:</h4>
<pre><code class="language-c line-numbers">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main () {
    char a[12] = "foo";
    char b[12] = "bar";
    char c[12];
    int l; //length for string a
    printf("a = %s\n", a );
    printf("b = %s\n", b );
    strcpy(c, a); //copy strings
    printf("c = %s\n", c );
    l = strlen(a); //string length
    printf("before length = %d\n", l);
    strcat( a, b); //concatenate strings
    printf("strcat( a, b): %s\n", a );
    l = strlen(a); //string length
    printf("after length = %d\n", l);
    return 0;
}</code></pre>

<h2>Structures</h2>

<p>A structure is known as&nbsp;<em>record</em>&nbsp;in other computer languages. It is a group of elements. Each element has a name and type. The elements can have different types. The type of element can be also a composite type. In this case the structure is sometimes called&nbsp;<em>aggregate</em>.</p>
<h4>Syntax:</h4>
<pre><code class="language-c line-numbers">struct name {
    type item_name;
    type item_name;
    ...
    type item_name;
} variable,...;
</code></pre>
<p><b>Notes:&nbsp;</b></p>
<ul>
<li>name is optional and variable is also optional but at least one must exist,</li>
<li>each item definition is ending with ";" not with "," as you may expect,</li>
<li>you can define one or more variables having same structure separated by comma,</li>
<li>structure declaration is ending with ";" after the variable names,</li>
<li>you can not define recursive structures, you must use pointers for this;</li>
</ul>
<h4>Example:</h4>
<pre><code class="language-c line-numbers">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
/* define structure of Book */
struct Project {
    char name[50];
    char author[50];
} foo, bar;
/* define a method to print Project info */
void PrintInfo (struct Project this){
    /* print project info */
    printf( "\n");
    printf( "project.name: %s\n", this.name);
    printf( "project.author: %s\n", this.author);
}
int main( ) {
    /* first project */
    strcpy( foo.name, "Bee Language");
    strcpy( foo.author, "Elucian Moise");
    /* second project */
    strcpy( bar.name, "C Language");
    strcpy( bar.author, "Dennis Ricthie");
    /* print project info */
    printf( "project: %s\n", foo.name);
    printf( "project: %s\n", bar.name);
    /* call function with structure argument */
    PrintInfo(foo);
    PrintInfo(bar);
    return 0;
}</code></pre>

<h2>Unions</h2>

<p>Union is similar to structure. In union the elements are exclusive. That is union type has a single value at a time. The memory reserved for union value is large enough to enable any value to be stored, but only last value assigned is stored.&nbsp;</p>
<h4>Example:</h4>
<pre><code class="language-c line-numbers">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
union Test {
    int i;
    float f;
    char s[20];
};
int main( ) {
        union Test a;
        union Test b;
        union Test c;
        a.i = 2;
        printf( "a.i = %d\n", a.i);
        b.f = 2.5;
        printf( "b.f = %f\n", b.f);
        strcpy( c.s, "test");
        printf( "c.s = %s\n", c.s);
        return 0;
    }</code></pre>
    <p>Alert: C will not initialize the elements of unions to correct values. You can get random values that may surprise you. Many times you&rsquo;r program will compile but will have logical errors. You must test everything 10 times before you can put a C program in production.</p>
    <h4>Example:</h4>
    <pre><code class="language-c line-numbers">#include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    union Test {
    int i;
    float f;
    char s[20];
};
int main( ) {
    union Test a;
    a.i = 2;
    printf( "a.i = %d\n", a.i);
    a.f = 2.5;
    printf( "a.f = %f\n", a.f);
    printf( "a.i = %d\n", a.i);
    strcpy( a.s, "test");
    printf( "a.s = %s\n", a.s);
    printf( "a.i = %d\n", a.i);
    printf( "a.f = %f\n", a.f);
    return 0;
}</code></pre>
<p><b>Unexpected Output:</b></p>
<pre><code class="language-output">a.i = 2
a.f = 2.500000
a.i = 1075838976
a.s = test
a.i = 1953719668
a.f = 77135366849413060736626594938880.000000</code></pre>

<h2>Bit fields</h2>

<p>Normally, Boolean values are stored in computer memory as unsigned integers. One integer has 4 bytes. So one Boolean value will occupy 4 bytes even if only 1 byte is necessary to store one Boolean value.</p>
<p>To save space you can group multiple Boolean values (logic flags) into one single variable of type&nbsp;<em>struct</em>&nbsp;with bit fields. To define a bit field you specify the length of the field after ":". Obvious the length must be smaller than the data type of the element.</p>
<h4>Example:</h4>
<pre><code class="language-c line-numbers">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
/* define b as mask of 3 bites */
struct {
    unsigned int one :1;
    unsigned int two :1;
    unsigned int three:1;
    unsigned int other:5;
} b;
int main( ) {
    b.one = 1; //true
    b.two = 0; //false
    b.three = 3; //not Boolean
    b.other = 12; //not Boolean
    printf( "b-size %d\n", sizeof(b)); //expected: 4 (bytes)
    printf( "b.one = %i\n", b.one); //expected: 1
    printf( "b.two = %i\n", b.two); //expected: 0
    printf( "b.three = %i\n", b.three); //unexpected result: 1
    printf( "b.other = %i\n", b.other); //expected 12: can fit in 5 bites
    return 0;
}</code></pre>
<p><b>Caution:&nbsp;</b>If you assign a value that will not fit in the number of bits allocated the result can be incorrect but you get no error. In the example above the value of item&nbsp;<em>three&nbsp;</em>is corrupted<em>. </em>Does not fit in 1 byte correctly while&nbsp;<em>other&nbsp;</em>field is also not Boolean but is correct. It fits in 5 bits reserved by structure.</p>

<h2>Type Alias</h2>

<p>A type alias is a name given to user defined type. You can use keyword&nbsp;<em>typedef</em>&nbsp;to define a new type. The type you define can be used to declare global or local variables, parameters or function result.</p>
<p>Syntax:</p>
<p>typedef composite_type type_name;&nbsp;</p>
<ul>
<li>typedef ::= keyword</li>
<li>type_name ::= type alias (identifier)</li>
<li>composite_type ::= { union | struct | array }</li>
</ul>
<h4>Example:</h4>
<pre><code class="language-c line-numbers">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
/* create a type with alias */
typedef struct {
    unsigned int one :1;
    unsigned int two :1;
    unsigned int three:1;
} Mask;
int main( ) {
    /* local variable based on user defined type */
    Mask b;
    /* assign values for each element */
    b.one = 1;
    b.two = 2;
    b.three = 3;
    printf( "b.one = %i\n", b.one); // 1
    printf( "b.two = %i\n", b.two); // 0
    printf( "b.three = %i\n", b.three);// 1
    return 0;
}</code></pre>
<p><b>Observe:</b>&nbsp;<em>b.two</em>&nbsp;and&nbsp;<em>b.three&nbsp;</em>are corrupted values. This is on purpose for giving an example how wrong things can go if you are not consistent. You can forget what you meant when you do not comment your code. Then you can do something stupid and C will just have unexpected secondary effects with no warning or error. Therefore C is not a&nbsp;<em>safe</em>&nbsp;language.</p>
<h4>Example:</h4>
<p>If the composite type is already defined, you can create a type alias after or before its declaration. C compiler is using "hoisting" technique to find forward declarations. In next example we define a list of points, and we create two points in the list.</p>
<pre><code class="language-c line-numbers">#include &lt;stdio.h&gt;
/* declare a struct named point */
typedef struct {
    int x;
    int y;
} point;
/* declare a type t_list from list */
typedef struct list t_list;
/* declare structure: list of points */
struct list {
    point p;
    t_list *next;
};
int main() {
    /* define 2 members in a list */
    t_list last = { .p = { .x = 3, .y =7 }, }; // last element
    t_list first = { .p = { .x = 4, .y =5 }, .next = &amp;last }; // first element
    /* accessing first element */
    printf("first.x = %d\n", first.p.x);
    printf("first.y = %d\n", first.p.y);
    /* accessing next element */
    printf("next.x = %d\n", first.next-&gt;p.x);
    printf("next.y = %d\n", first.next-&gt;p.y);
} </code></pre>
<p><b>Observe:&nbsp;</b>The structure t_list is recursive and nested. It is a list of points, where a point is also a structure of two integers: x, y. This structure has only two members but it could have more.</p>
<ul>
<li>We use pointer *next to connect first element with last element;</li>
<li>You can assign values for elements by name using dot notation: .p=, .x=, .y=</li>
</ul>
<h4>Example:</h4>
<pre><code class="language-c line-numbers">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct {
    int x;
    int y;
} Struct; //define a type
// function with multiple results
Struct get_s() {
    Struct s = {1, 2};
    return s;
}
int main () {
    Struct s; //variable not pointer
    s = get_s();
    printf ("s = {%d,%d}",s.x,s.y);
    return 0;
}</code></pre>
<p><b>Note:&nbsp;</b>In previous example a function get_s() return a structure not a pointer. This is a single result with encapsulated elements. Observe that returning a structure do not require "static" keyword for variable "s". Since this is a structure is transferred outside of the function using "copy" unlike vectors that are pointers so they must be declared static to be returned by a function.&nbsp;</p>

<hr>

<p><b>Read next:</b>
<a href="pointers.html">Pointer Arithmetic</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>


</div>


</body>
</html>