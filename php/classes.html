<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Object Oriented concepts in PHP.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="learn, php, oop, object, class">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>PHP Classes</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="../prism.css">
  <script src="../prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>  
    <div class="col  bottom-right">
        <a href="index.html#php-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>

<h2>PHP Classes</h2>

<div class="alert alert-secondary shadow-sm">
You can say PHP is a multi-paradigm computer language. It is mostly imperative and structured but also object oriented. You can define classes, interfaces, traits and you can instantiate objects using a constructor, similar to other OOP languages.</div>

<h2>OOP Concepts</h2>

<p>PHP, enabling all three pillars of object oriented programming<em>&agrave; la carte</em>.
To learn PHP thorough you must understand these principles. 
We explain these concepts in our Computer Science course next year.
</p>

<ul>
<li>Encapsulation</li>
<li>Inheritance</li>
<li>Polymorphism</li>
</ul>

<h2>Classes&nbsp;</h2>
<p>A class is a code fragment identified by a name that can be used as a namespace or as a template.
It is created with keyword <em>class</em> and it encapsulate declarations of variables 
called "properties" and functions that are called "methods". 
There are some other keywords directly associated with declaration of a class. 
I will introduce you to an example and explain what is all about.</p>

<h4>Example:</h4>
<p>This example is a simplified class, to learn the basic principles:</p>
<pre><code class="language-php line-numbers">&lt;?php
/* define a simple class */
class SimpleClass
{
    // property declaration
    public $var = 'default value';
    
    // method declaration
    public function displayVar() {
        echo $this-&gt;var,"&lt;br&gt;";
    }
}
// create a new object
$object = new SimpleClass;
// call a method
$object-&gt;displayVar();
// access public property
echo $object-&gt;var;
?&gt;</code></pre>

<p><b>Notes:&nbsp;</b></p>
<ul>
<li>You define a class with keyword: class,</li>
<li>Class name is case sensitive,</li>
<li>A class is a block of code,</li>
<li>A class can have nested functions, called methods,</li>
<li>You can create an "object" using keyword "new",</li>
<li>You can access object methods using operator "-&gt;"</li>
<li>You can access object public properties using operator "-&gt;"</li>
</ul>

<p><b>Frequent Q&amp;A:</b></p>
<div>

<table class="table table-bordered table-striped table-dark" >
<tbody>
<tr>
<th>Questions</th>
<th>Answers</th>
</tr>
<tr>
<td>What is a Class?</td>
<td>A Class is a template.</td>
</tr>
<tr>
<td>What is an Object?</td>
<td>An object is an instance of a class.</td>
</tr>
<tr>
<td>Can I have more than one object?</td>
<td>Yes you may have as many objects as you need.</td>
</tr>
<tr>
<td>Is a Class good for anything else?</td>
<td>Yes, a Class can serve as a namespace.</td>
</tr>
</tbody>
</table>
</div>

<h2>PHP Objects</h2>
<p>An object is an instance of a class. The purpose of an object is to encapsulate data and methods that can deal with this data. That is first principle of the OOP: <em>encapsulation.</em></p>

<p>There are two variables that are predefined in PHP and are very important: <em>self</em> and <em>$this</em>. Though <em>self</em> keyword is also used in Python and Java, for PHP this keyword has a very distinct significance:</p>
<ul>
<li>self: represents the current class;&nbsp;</li>
<li>$this: represents the current object instance</li>
</ul>
<h4>Notes:</h4>
<ol>
<li>Members for <em>"$this"</em> are accessed using "member operator" that is <code class="language-php">-&gt;</code>;</li>
<li>Members for <em>"self"</em> are accessed using "scope operator" that is <code class="language-php">::</code>.</li>
</ol>
<h2>Static members</h2>
<p>Members of a class can be declared "static". That means these members will belong to class and not to object. 
So if they belong to a class they can be used without instantiation, but there is a catch. 
In PHP accessing static members is done using symbol :: notthe common symbol -&gt; 
that may be familiar to you from C language (or not).&nbsp;</p>
<h4>Example:</h4>
<pre><code class="language-php line-numbers">&lt;?php
/* define a abstract class */
class Foo
{
    public static $my_static = 'foo';
    public static function staticValue() {
        return self::$my_static;
    }
}
//accessing static property
echo Foo::$my_static; // foo
echo "&lt;br&gt;";
//accessing static method
echo Foo::staticValue(); // foo
echo "&lt;br&gt;";
?&gt;</code></pre>

<h4>Notes:</h4>
<ul>
<li>Static members can be used with class name using "::",</li>
<li>Static members can be used with object name using "-&gt;".</li>
</ul>

<h2>Inheritance</h2>
<p>A class can be extended. That means we can create another class that can "extend" a base class. The new class has another name but "inherit" all the properties and all the methods of the "base class". This is the second property of OOP.</p>
<pre><code class="language-php line-numbers">&lt;?php
const EOL = "&lt;br&gt;";
// base class
class Foo
{
    public function printItem($string)
    {
        echo 'Foo: ' . $string . EOL;
    }
    public function printPHP()
    {
        echo 'PHP is great.' . EOL;
    }
}
// extended class
class Bar extends Foo
{
//overvrite function: printItem
    public function printItem($string)
    {
        echo 'Bar: ' . $string . EOL;
    }
}
$foo = new Foo(); // base object
$bar = new Bar(); // extended object
/* using extended object */
$foo-&gt;printItem('foo'); // Output: 'Foo: foo'
$foo-&gt;printPHP(); // Output: 'PHP is great'
/* using extended object */
$bar-&gt;printItem('bar'); // Output: 'Bar: bar'
$bar-&gt;printPHP(); // Output: 'PHP is great'
?&gt;</code></pre>

<h4>Notes:</h4>
<ul>
<li>function printItem() is implemented two times and overwritten;</li>
<li>function printPHP() is implemented a single time and inherited;</li>
</ul>

<h2>Constructor</h2>
<p>The constructor is a special function belonging to a class that is called automatically when an object is created using "new".  
The constructor name is __construct() and is optional. If a class is extending another class, the parent constructor can be called explicit using scope: <code>parent::__construct().</code></p>

<h4>Example:</h4>
<pre><code class="language-php line-numbers">&lt;?php
class BaseClass {
    function __construct() {
        echo "BaseClass constructor","&lt;br&gt;";
    }
}
class SubClass extends BaseClass {
function __construct() {
        parent::__construct();
        echo "SubClass constructor","&lt;br&gt;";
    }
}
$obj = new BaseClass();
$obj = new SubClass();
?&gt;</code></pre>

<p><b>Note:&nbsp;</b>Before PHP 5, constructor name was equal with class name. This convention is still available for backward compatibility. Many developers are using this convention so you may find old code without a _construct() method. Old style constructors are&nbsp;<em>DEPRECATED</em> in PHP 7.0.</p>

<h2>Destructor</h2>
<p>The destructor is a special method called __destruct() that has no parameters and no results. 
It is automatically called when an object goes out of scope. 
It can be used to release resources or to maintain static variables belonging to the class.</p>

<h4>Example:</h4>

<pre><code class="language-php line-numbers">&lt;?php
class MyClass {
    function __construct() {
        print "In constructor\n";
    }
    function __destruct() {
        print "Destroying " . __CLASS__ . "\n";
    }
}
$obj = new MyClass();</code></pre>

<p><b>Note:</b> A class can have multiple constructors with one or more parameters but only one destructor.&nbsp;</p>

<h2>Interface</h2>
<p>A class can extend a single other class. So there is no multiple inheritance and this is problematic. 
To resolve this problem, object oriented programming is using concept of "Interface". 
This is a special block of code that declare a "behavior" or "feature". 
A class can "implement" one or more interfaces.</p>

<h4>Example:</h4>

<pre><code class="language-php line-numbers">&lt;?php
// Declare the interface 'iTemplate'
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}
// Implement the interface
class Template implements iTemplate {
    private $vars = array();
    public function setVariable($name, $var) {
        $this-&gt;vars[$name] = $var;
    }
    public function getHtml($template) {
        foreach($this-&gt;vars as $name =&gt; $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
        return $template;
    }
}
//use Template class
$temp = new Template;
$temp-&gt;setVariable("a",10);
$temp-&gt;setVariable("b",20);
echo $temp-&gt;getHTML("test: a = {a}, b = {b}");
?&gt;</code></pre>

<p><b>Output:</b></p>

<pre><code class="language-output">test: a = 10, b = 20 </code></pre>

<p><b>Note:</b></p>
<ul>
<li>in previous example I have used keyword "private" to declare an internal attribute,</li>
<li>in interface, functions setVariable and getHtml are just declared not implemented,</li>
<li>in class, all functions that are declared by interface must be implemented.</li>
</ul>

<h2>Member visibility</h2>
<p>The visibility of a property, a method or constant can be defined by prefixing the declaration with the keywords: 
{ <em>public</em>, <em>protected</em>, <em>private</em>};

<ul>
<li>Public members are visible from outside the class using object name and scope operators,</li>
<li>You can call private members only inside the class using <code>self::</code> or <code>$this-&gt;</code>,</li>
<li>Protected members can be accessed from child classes but not from outside the class,</li>
<li>Constants declared without any explicit visibility keyword are defined as public.</li>
</ul>

<h2>Abstract classes</h2>
<p>These kind of classes are similar to interfaces, except they are designed to be inherited. 
They are usually base classes for some other classes that extend them. 
One abstract class can have many children, but each children can have only one parent class.&nbsp;</p>

<h4>Example:</h4>

<pre><code class="language-php line-numbers">&lt;?php
abstract class AbstractClass
{
// Our abstract method only needs to define the required arguments
    abstract protected function prefixName($name);
}
class ConcreteClass extends AbstractClass
{
//  Our child class may define optional arguments not in the parent's signature
    public function prefixName($name, $separator = ".") {
        if ($name == "Pacman") {
            $prefix = "Mr";
        } elseif ($name == "Pacwoman") {
            $prefix = "Mrs";
        } else {
            $prefix = "";
        }
    return "{$prefix}{$separator} {$name}";
    }
}
$class = new ConcreteClass;
echo $class-&gt;prefixName("Pacman"), "&lt;br&gt;";
echo $class-&gt;prefixName("Pacwoman");
?&gt;</code></pre>

<p><b>Note:&nbsp;</b>Abstract classes can declare abstract methods. These methods have only a signature. The implementation of the method is done in a concrete class. All the abstract methods must be implemented.</p>

<h2>Traits</h2>

<p>This is something very modern. It is an alternative form of code re-usability based on components. 
A trait is an "augment" that can be "used" into a class to extend its capabilities.</p>

<p>Unlike interfaces, traits have ready made functions, constants or variables. 
You do not have do implement them again in your class. 
When a trait is used, trait members become class members.&nbsp;</p>

<p>Multiple traits can be combined into an "aggregate", that is a larger trait. 
By using the aggregate we can extend a class with functionality without writing new code and without using mix-ins.</p>

<h4>Example:</h4>
<pre><code class="language-php line-numbers">&lt;?php
/* define first trait */
trait Hello {
        public function sayHello() {
        echo 'Hello ';
    }
}
/* define second trait */
trait World {
    public function sayWorld() {
        echo 'World';
    }
}
/* using two traits */
class MyHelloWorld {
    use Hello, World;
    public function sayExclamationMark() {
        echo '!';
    }
}
/* testing the new class */
$o = new MyHelloWorld();
$o-&gt;sayHello(); //first trait function
$o-&gt;sayWorld(); //second trait function
$o-&gt;sayExclamationMark(); //class function
?&gt;</code></pre>

<p><b>Note:</b> Using traits is a bit more complicated than this example but that's the essential. You can read more about traits in official manual when you are in situation to start using them. Until you do, let's continue with something else that may be more important.</p>

<hr>

<p><b>Read next:</b>
<a href="exceptions.html">Exceptions</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>


</div>
</body>
</html>