<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Introduction to Dart functions.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, dart, functions, functional, programming">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Dart Functions</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="https://sagecode.net/prism.css">
  <script src="https://sagecode.net/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">

<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>

<h1>Dart Functions</h1>

<div class="alert alert-secondary shadow-sm">
Dart functions are objects of type Function. That means functions can be assigned to variables or passed as arguments to other functions. So Dart is an Object Oriented language with functional features.
</div>

<h2>Page bookmarks</h2>

<ul>
<li><a href="#concept-syntax">Concept &amp; Syntax</a>
<ul>
    <li><a href="#syntax-pattern">Syntax pattern</a></li>
    <li><a href="#arrow-notation">Arrow notation</a></li>
    <li><a href="#parameters">Parameters</a></li>
    <li><a href="#results">Results</a>
</li>
</ul>
<li><a href="#first-class-functions">First-class functions</a></li>
<li><a href="#anonymous-functions">Anonymous functions</a></li>
<li><a href="#function-scope">Function scope</a></li>
<li><a href="#define-closure">Define closure</a></li>
</ul>

<h2><a id="concept-syntax"></a> Concept &amp; Syntax</h2>

<p>Functions are reusable fragments of code. Usually a function has a name, accept input and produce output. You can use functions to resolve a small problem. Maybe you need to resolve same problem multiple times with some variations, handled by input parameters.</p>

<div class="text-center">
  <img src="../images/function.jpg" alt="continue" srcset="../images/function.svg" width="520" class="img-fluid protect rounded shadow border" >
  <p>Function Concepts</p>
</div>

<h3><a id="syntax-pattern"></a>Syntax pattern:</h3>

<p>Most common a function declaration start with data type, then function name followed by a list of parameters enclosed in brackets and separated by comma. A regular function have also a block of code delimited by curly brackets {} immediately after the parameters closing bracket.</p>

<pre><code class="language-dart line-numbers">//function declaration
type name(type param,...) {
   //statements
   ...
   return expression;
}
</code></pre>

<p>When function do not return a result, you can use keyword "void". But if function do not have parameters you must use an empty list like this: ().</p>

<pre><code class="language-dart line-numbers">//void function
void name() {
   //statements
   ...
}
</code></pre>

<h4>Example:</h4>

<p>Any Dart program must have a function main(). This is the entry point of application. If this function is not found, the program will not run.</p>

<pre><code class="language-dart line-numbers">//simple function
void main() {
  print('Hello, World!');
}
</code></pre>

<h3><a id="arrow-notation"></a>Arrow notation</h3>

<p>Simple functions based on expressions do not need a return type and you can use symbols: "=>" that look like an arrow to point out the result as an expression. This notation is called "arrow function" and is also well known in JavaScript.<p>

<h4>Example:</h4>

<pre><code class="language-dart">int sum(int a, int b) => a + b;</code></pre>

<h3><a id="parameters"></a>Parameters</h3>

<p>Like most other languages Dart functions can have a list of parameters that are enumerated after function name. Parameters are declared like any other variable with type and name. If more than one they are separated by comma. Parameters can be "positional" or "named" parameters.</p>

<h4>Positional parameters</h4>

<p>Positional parameters require arguments of same type in the respective position as the parameters. Positional parameters can not have initial values unless they are also optional.</p>

<h4>Example:</h4>

<p>Now you can see the previous array function again, used into a real program:</p>

<pre><code class="language-dart"> // function with mandatory parameters
int sum(int a, int b) => a + b;

void main() {
	var s = sum(4,4);
    print('s= $s');
}
</code></pre>

<h4>Optional parameters</h4>

<p>To define optional parameters is not enough to assign them the initial values. It is required to enclose them also in square brackets. This is Dart specific convention: One single square parenthesis contains all optional parameters, separated by comma.</p>

<pre><code class="language-dart">// function with optional parameters
int sum(int a, int b, [int c=0, int d=0]) => a + b + c + d;

void main() {
    //provide only 2 parameters
    var s1 = sum(4,4);
    print('s= $s1'); // 8
    //provide 3 parameters
    var s2 = sum(4,4,5);
    print('s= $s2'); // 13
    //provide 4 parameters
    var s3 = sum(4,4,5,6);
    print('s= $s3'); // 19
}
</code></pre>

<p><b>Homework:&nbsp;</b>Time for a little exercise lazy boy!. Open this example on-line and add another optional parameter so you can have 5 numbers added in the sum function. Link: <a href="https://repl.it/@elucian/dart-params#main.dart" target="_blank" rel="noopener noreferrer nofollow">dart&nbsp;params</a></p>

<h4>Named parameters</h4>

<p>Dart has a special convention to define named parameters. These parameters must be enclosed in curly brackets like a data set. A little bit difficult o get used to it, pay attention to the example:</p>

<pre><code class="language-dart">// function with named optional parameters
int sum(int a, int b, {int c=0, int d=0}) => a + b + c + d;

void main() {
    var s1 = sum(4,4,d:5);
    print('s1 = $s1'); // 13
    var s2 = sum(4,4,c:5);
    print('s2 = $s2'); // 13
    var s3= sum(4,4,c:2,d:3);
    print('s3 = $s3'); // 13
}
</code></pre>

<p><b>Homework:&nbsp;</b>Exercise again, I know you love it!. Open this example on-line and fix it, WITHOUT COPY PASTE. It is full of errors: <a href="https://repl.it/@elucian/dart-nparams#main.dart" target="_blank" rel="noopener noreferrer nofollow">dart&nbsp;nparams</a></p>

<h3><a id="results"></a>Results</h3>

<p>In a regular declaration you should have at least one "return" statement that is usually at the end of the function block. You may have several return statements, each can produce one result in different conditions.</p>

<h4>Example:</h4>

<pre><code class="language-dart line-numbers">//function with null result
double div(int a, int b) {
   if (b != 0) {
      return a/b;
   }
   return null;
}

void main() {
   print(div(1,2)); //0.5
   print(div(1,0)); //null
}
</code></pre>

<p>All functions return a value. If no return value is specified, the statement "return null;" is implicitly appended to the function body. This is a simple function that return null:</p>

<pre><code class="language-dart line-numbers">//simple function
foo() {}

void main() {
    assert(foo() == null);
}
</code></pre>

<h2><a id="first-class-functions"></a>First-class functions</h2>

<p>Dart have First-class functions. That is functions are treated like any other variable. For example, in Dart, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable.</p>

<h4>Example:</h4>

<pre><code class="language-dart line-numbers">//simple arrow functions
int sum(int p1, int p2) => p1 + p2;
int dif(int p1, int p2) => p1 - p2;

//function with function as parameter
int test(Function f, int a, int b) {
  return f(a,b);
}

void main() {
   int x = test(sum, 12, 10) ;
   print(x); //22

   int y = test(dif, 12, 10) ;
   print(y); //2
}
</code></pre>

<p><b>Note:&nbsp;</b>A function that handle first-class functions are called <em>hig order functions</em>. In previous example, function test, accept parameter f that is a function. The functions sum/dif are used as arguments.</p>

<h2><a id="anonymous-functions"></a>Anonymous functions</h2>

<p>In general, functions have names, but sometimes not. Anonymous functions can be used as arguments or definitions that can be stored as collection elements. The syntax is similar to normal function, except there is no name and often no result type.</p>

<h4>Pattern:</h4>

<p>Next syntax pattern demonstrate anonymous function declaration.</p>

<pre><code class="language-dart line-numbers">//anonymous function
(type param, ...) {
  //statements
  ...
  return expression;
};
</code></pre>

<p>Of course also arrow pattern will enable creation of anonymous functions:</p>

<pre><code class="language-dart">(type param, ...) => expression;</code></pre>

<h4>Example:</h4>

<p>We can rebuild the example above to use anonymous functions as parameters:</p>

<pre><code class="language-dart line-numbers">//function "f" as parameter
int test(Function f, int a, int b) {
  return f(a,b);
}

void main() {
   int x = test((int p1, int p2) => (p1 + p2), 12, 10) ;
   print(x); //22

   int y = test((int p1, int p2) => (p1 - p2), 12, 10) ;
   print(y); //2
}
</code></pre>

<h2><a id="function-scope"></a>Function scope</h2>

<p>A function has a local scope. This is a region of code where function parameters and function variables are visible. This scope is limited to function block. You can define anonymous inner blocks using nested brackets: {...{...}}. </p>

<div class="alert alert-warning"><span style="color:brown">No hoisting:&nbsp;</span>You can define a variable anywhere in the scope, but Dart do not recognize variables until they are defined. That means a variable defined at the end of the block is not available at the beginning of the block!</div>

<h4>Example 1: nested scope</h4>

<p>In the next example variable x is modified inside the inner block and take value 7 that is propagated to outer block with no problem. </p>

<pre><code class="language-dart line-numbers">//nested lexical scope
void main() {
    var x = 2;
    {
       print("x = $x"); // x = 2
       x = 7;
    }
    print("x = $x"); // x = 7
}
</code></pre>

<h4>Example 2: var shadowing</h4>

<p>In the next example variable x is redefined inside the inner block and then modified. The new value do not propagate to outside of the block. Variable x was shadowed by the local new variable x. </p>

<pre><code class="language-dart line-numbers">//nested lexical scope
void main() {
    var x = 2;
	{
       var x = 7;
       print("x = $x"); // x = 7
    }
    print("x = $x"); // x = 5 (not 7)
}
</code></pre>


<p><b>Note:</b>Dart compiler is very thorough. It will not let you redefine a variable that is already used prior to declaration inside the nested block. Only unused variables can be redefined and shadowed!</p>

<h4>Example 3: param shadowing</h4>

<p>In Dart you can also define a function nested inside other function. That means function scope is nested. The outer function variables are visible in the inner function but the inner variables are isolated from the outer function.</p>

<pre><code class="language-dart line-numbers">//parameter can shadow outer variables
void main() {
    var x = 2;
    var y = 4;
    int test(int x) {
       print("x = $x"); // x = 2
       print("y = $y"); // y = 4
       x = 7;  // ignored
       y = 7;  // accepted
    }
    test(x);         // send x = 2
    print("x = $x"); // x = 2 (not 7)
    print("y = $y"); // y = 7 (not 4)
}
</code></pre>

<h2><a id="define-closure"></a>Define closure</h2>

<div class="alert alert-secondary">By definition a closure is a function object that has access to variables in its lexical scope, even when the function is used outside of its original scope. By enabling this feature we can create <em>high order functions</em> that can produce as a result a function for every call.</div>

<h4>Example:</h4>

<p>Don't panic. Is not so complicated as it sound. The trick is to look at the example below. The outer function "foo" create a closure "bar". What is intreating is that we can create two version of "bar". Each version remember different states of "foo". That is, the bar instances remember the parent lexical scope.</p>

<pre><code class="language-dart line-numbers">//high order function
Function foo(int delta) {
  return (int x) => delta + x;
}

void main() {
  var test = 0;
  //create first closure
  var bar1 = foo(10);
  test = bar1(2);
  print(test); //expect 12
  //create second closure
  var bar2 = foo(20);
  test = bar2(2);
  print(test); //expect 22
}
</code></pre>

<p><b>Comment:&nbsp;</b>In example above, "foo" is like a factory of "bar" functions. Then function "foo" is very similar to a class and "bar" is very similar to an object. That is in fact the technique used by functional programming languages to cover the lack of classes.</p>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="classes.html">Classes</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>