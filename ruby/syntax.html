<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Introduction to Ruby language syntax.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="ruby, comments, syntax">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Ruby Syntax</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="https://sagecode.net/prism.css">
  <script src="https://sagecode.net/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>  
    <div class="col  bottom-right">
        <a href="index.html#ruby-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>

<h2>Ruby Syntax</h2>

<div class="alert alert-secondary shadow-sm">
Ruby is case sensitive and has similar naming rules to other languages. You can define identifiers that start with an alphabetic character or underscore. Some identifiers start with capital letters.&nbsp;
</div>

<p>Unlike Python that has mandatory indentation, in Ruby the indentation is optional. Multiple statements can be separated using symbol ";" but this symbol is not required for single line statements.</p>
<p>Unlike other languages that have one single convention for a block of code, Ruby has 2 kind of block statements. One is enclose by curly brackets {...} other blocks are using keywords.</p>
<p>When you write Ruby code you actually create scripts. These are text files with extension *.rb. Most script files start with a special comment: #! as in example below:</p>

<p><b>First script:</b></p>

<pre><code class="language-ruby line-numbers">#!/usr/bin/ruby -w
puts "Hello, Ruby!";</code></pre>

<p>You can run this script using ruby interpreter:</p>
<p>&gt;ruby hello.rb</p>

<h4>Example:</h4>

<p>This is just a fancy "hello world" script that I will explain next:</p>
<pre><code class="language-ruby line-numbers"># The Greeter class
class Greeter
  def initialize(name)
    @name = name.capitalize
  end

  def salute
    puts "Hello #{@name}!"
  end
end

# Create a new object
g = Greeter.new("world")

# Output "Hello World!"
g.salute</code></pre>

<p><b>Homework:&nbsp;</b>open live demo and run it:&nbsp;
<a href="https://repl.it/@elucian/ruby-hello" target="_blank" rel="noopener noreferrer">hello world</a></p>

<h4>Notes:</h4>
<ul>
<li>line of comment start with "#" like in Python,</li>
<li>there is no ";" for end of statement,</li>
<li>a class is a named block of code like in Python,</li>
<li>a method of a class start with keyword&nbsp;<em>"def"&nbsp;</em>like in Python,</li>
<li>block of code is ending with "end" like in Pascal,</li>
<li>assign is using symbol "=" not ":=" that is used in Pascal,&nbsp;</li>
<li>call of function&nbsp;<em>puts</em>&nbsp;do not require (&hellip;), unlike Python,</li>
<li>symbol @ is a "<em>sigil</em>" for an attribute,</li>
<li>string is enclosed in double quotes: "&hellip;",</li>
<li>notation #{@name} is:&nbsp;<em><b>string interpolation.</b></em></li>
</ul>

<p class="alert alert-info"><b>Clarification:&nbsp;</b>This is how we learn Ruby in this tutorial. I will show you an example or more, that may be overwhelming at first glance. Then you execute the example once or several times on-line using&nbsp; repl.it website. Analyze the output an read the notes to understand the new concepts.</p>

<h2>Block Comments</h2>
<p>In most languages block comments are enclosed in this notation: /* &hellip; */. In Ruby this kind of comment is not available. Instead you can use&nbsp;<code>=begin ... =end</code>&nbsp;notation. Block comments are sometimes called "embedded documentation". It is a good practice to use these kind of comments to explain code purpose.</p>

<h4>Example:</h4>
<pre><code class="language-ruby line-numbers">=begin
This demo does absolutely nothing.
In Ruby the null statement is nil
=end

# define a subroutine that does nothing
def pass
  nil # nothing expression
end

pass # call subroutine pass one time

=begin
Also the simple semicolumn ';'
does absolutely nothing 
=end

;;;  # call null statement 3 times</code></pre>

<h2>Block Statement</h2>

<div class="alert alert-secondary shadow-sm">
In Ruby there are statements that encapsulate other statement in a linear <em>block of code.</em> 
These statements start with a significant code line followed by several indented statements.
A block statement is closed with keyword <em>end</em>.
In Ruby the indentation is optional, unlike Python where the indentation is mandatory.
</div>

<h4>Example:</h4>
<pre>
<code class="language-ruby"># block statement
for x in 1..10 do
    next if x % 2 == 0
    print x," " # 1 3 5 7 9
end
</code></pre>

<p><b>Notes:</b> 
<ul>
<li>In previous example I have used statement "for" that is a block statement. </li>
<li>Indentation is usually done with equal 2 or 4 number of spaces;</li>
<li>Block statements are closed with "end" and can be nested.</li>
</ul>


<h2>Keywords</h2>
<p>Most keywords are English words. Some keywords are using uppercase but most of them are using only lowercase letters. Ruby has about 40 keywords that I will introduce step by step using examples.</p>

<pre><code class="language-ruby line-numbers">----------------------------------------------------------------
__FILE__  and    def       end     in      or      self   unless
__LINE__  begin  defined?  ensure  module  redo    super  until
BEGIN     break  do        false   next    rescue  then   when
END       case   else      for     nil     retry   true   while
alias     class  elsif     if      not     return  undef  yield
----------------------------------------------------------------
</code></pre>

<h4>Code Line</h4>

<div class="alert alert-secondary shadow-sm">A code line, is simple put a text row ending with <em>new line</em>. 
It has a visual representation as: Â¶
It is interpreted as (CR+LF) on Windows and (LF) on Linux. 
Most of editors do not show this hidden symbol.
</div>

<p>In Ruby one statement is usually single code.  
However not all statement are on a single line. 
Sometimes one code line can have many statements separated by semicolumn (;). 
When a statement is too long, it can be continued on next lines.
</p>

<p>There are two ways to break a statement in multiple code lines.
Fitst, you can use backslash (\) at end of line the continue on the next line.  
Second, a code line that end with an operator like "+" may continue on next line. 
In this case the continuation operator "\" is not necessary.</p>

<h3>Statements</h3>

<div class="alert alert-secondary shadow-sm">
  A simple statement is usually on line of code that contains exressions and symbols.
  There are several kind of statements. The most usual form of statement is the assign statement.
  One larger statement called <em>block statement</em> can include several other simple statements.    
</div>

<p>Ruby is an imperative, object oriented language. 
Therefore, most statements are using a keyword to start, 
except the assign statement that start with an identifier. 
</p>

<h2>Expressions</h2>
<p>You should be familiar with this concept from mathematics. In Ruby you can use infix expressions. Here is a short reminder:&nbsp;<em>Infix,&nbsp;Postfix&nbsp;</em>and&nbsp;<em>Prefix&nbsp;</em>notations are three different but equivalent ways of writing expressions. It is easiest to demonstrate the differences by looking at examples of operators that take two operands:</p>

<ol>
<li>x + y&nbsp; : Infix</li>
<li>+ x y&nbsp; : Prefix</li>
<li>x y +&nbsp; : Postfix</li>
</ol>

<p>In these expressions x, y are operands while "+" is an operator.&nbsp;The most simple expressions are using one single operator and one operand. For example "-4" is an expression while "4" is not an expression but a single constant literal.&nbsp; "2 + 4" however is an expression even if there is no variable involved.</p>

<p>Usually expressions are used in statements. In Ruby&nbsp;<em>stand alone expressions</em>&nbsp;can exist and can represent the result of a function or method. I personally don&rsquo;t like this approach, it can make the script harder to understand.</p>

<h3>Elements</h3>

<p>The most simple expressions are called "elements". Elements and small expressions can be combined in larger expressions. Order of execution can be controlled using&nbsp;<em>operator precedence</em>&nbsp;and round parenthesis. We will investigate this in our next examples.</p>

<h4>Identifiers</h4>

<div class="alert alert-secondary shadow-sm">
An <em>identifier</em> is a name that we give to a syntax element. 
Think about identifiers like labels or tags you apply for things. 
Identifiers can be a sincle character or several characters up to 32. 
One identifier start with a letter and can contain letters, numbers and underscore (_).
</div>

<h4>Variables</h4>

<div class="alert alert-secondary shadow-sm">
A name that is given to a value that can be modified later is called a variable.
Sometimes a variable can represent a memory address.
In this case a <em>variable</em> represents a <em>refference</em>.
In other words, variables are value identifiers.
In Ruby all variable identifiers start with "$".
</div>

<h4>Constants</h4>

<div class="alert alert-secondary shadow-sm">
A constant is a type of variable whose value cannot be changed. It is helpful to think of constants as containers that hold information which cannot be changed later. Ruby have a convention to use start with capital letter, but usually all letters are capitalized. Ruby has these predefined constants.
</div>

<pre><code class="language-ruby"># predefined constants
TRUE, FALSE
NIL
STDIN, STDOUT
STDERR
ENV
ARGF, ARGV
DATA
RUBY_VERSION
RUBY_RELEASE_DATE
RUBY_PLATFORM
</code></pre>

<h4>Literals</h4>

<div class="alert alert-secondary shadow-sm">
A literal is a value symbol that can be a number, string or collection of values. The literal is also truly constant.
You can not change value of literals during runtime. For example: 520 is a literal but "520" is also a literal. 
Literals represents hard coded data.
</div>

<h4>Example:</h4>
<pre>
<code class="language-ruby">5
24
520
'a'
"test"
[1,2,3]
</code></pre>

<h2>Numeric Operators:</h2>

<p>Operators are data type dependent. 
So for each data type should have a different set of operators.
However, Ruby is smart enaugh to make automatic conversion between different data types.
We say numeric operators are polymorph. They can operate integers and float numbers.</p>

<table class="table table-bordered table-striped table-dark" >
<tbody>
<tr>
<th>Operator</th>
<th>Name</th>
<th>Example</th>
<th>Result</th>
</tr>
<tr>
<td>+</td>
<td>Addition</td>
<td>x+y</td>
<td>Sum of x and y.</td>
</tr>
<tr>
<td>&ndash;</td>
<td>Subtraction</td>
<td>x-y</td>
<td>Difference of x and y.</td>
</tr>
<tr>
<td>*</td>
<td>Multiplication</td>
<td>x*y</td>
<td>Product of x and y.</td>
</tr>
<tr>
<td>/</td>
<td>Division</td>
<td>x/y</td>
<td>Quotient of x and y.</td>
</tr>
<tr>
<td>%</td>
<td>Modulus</td>
<td>x%y</td>
<td>Remainder of x divided by y.</td>
</tr>
<tr>
<td>**</td>
<td>Exponent</td>
<td>x**y</td>
<td>x**y will give x to the power y</td>
</tr>
</tbody>
</table>

<p><b>Examples</b></p>

<pre><code class="language-ruby line-numbers"># expressions demo:
puts (5 + 5) / 2   # 5
puts  5 + 5  / 2   # 7
puts  5 + 5  / 2.0 # 7.5
puts  5 + 2  * 2   # 9
puts (5 + 2) * 2   # 14

# unexpected result:
print [5 + 2] * 2 # [7, 7]</code></pre>


<h4>Notes:</h4>
<ol>
<li>In this example we have used 3 numeric operators: { +, /, *}. That should be familiar to you: Addition, division and multiplication. In computer science we have a scarce number of operators due to legacy ASCII notation. { &divide;&nbsp; &middot; } are Unicode symbols for division and multiplication, not available in Ruby.</li>
<li>Square bracket [&hellip;] and squiggly brackets {&hellip;} are used in mathematics to control the order of operations but not in Ruby. Notation [5 + 2] create an array with one element [7] that is replicated into [7, 7]. Totally unexpected result isn&rsquo;t it?</li>
</ol>


<h3>Numeric Modifiers</h3>

<p>Modifiers are <em>in place operators</em> that alter value associated to an identifier.
Modifiers are also assignment statements. Python modifiers are inherited from C language.
Modifiers can accept expressions not only constants.
</p>

<div class="table-wrapper">
<table class="table table-bordered table-striped table-dark" >
<tbody>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
<th>Equivalent</th>
</tr>
<tr>
<td class="ts">+=</td>
<td>Addition and assignment operator.</td>
<td>c += a</td>
<td>c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>Subtraction and assignment operator.</td>
<td>c -= a&nbsp;</td>
<td>c = c &ndash; a</td>
</tr>
<tr>
<td>*=</td>
<td>Multiply and assignment operator.</td>
<td>c *= a</td>
<td>c = c * a</td>
</tr>
<tr>
<td>/=</td>
<td>Divide and assignment operator.</td>
<td>c /= a</td>
<td>c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>Modulus and assignment operator.</td>
<td>c %= a</td>
<td>c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>Exponent and assignment operator.</td>
<td>c **= a</td>
<td>c = c ** a</td>
</tr>
</tbody>
</table>

<div class="alert alert-danger shadow-sm">There are two common operators: increment (++) and decrement (--)
available in many C like languages including JavaScript. These two operators are not available in Ruby.
</div>

<hr>

<h3>Bitwise Operators</h3>
<p>Next operators are acting at bit level. They are inherited from C language. 
   An operator usually has 2 operands but one of these operators has only one operand. 
   Which one? Read description for each operator to find out!
</p>
<table class="table table-bordered table-striped table-dark" >
<tbody>
<tr>
<th>Operator</th>
<th>Name</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>&amp;</td>
<td>Binary AND</td>
<td>Operator copies a bit to the result if it exists in both operands</td>
<td>(a &amp; b)</td>
</tr>
<tr>
<td>|</td>
<td>Binary OR</td>
<td>It copies a bit if it exists in either operand.</td>
<td>(a | b)</td>
</tr>
<tr>
<td>^</td>
<td>Binary XOR</td>
<td>It copies the bit if it is set in one operand but not both.</td>
<td>(a ^ b)</td>
</tr>
<tr>
<td>~</td>
<td>Binary Ones Complement</td>
<td>It is unary and has the effect of 'flipping' bits (not).</td>
<td>(~a )</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>Binary Left Shift</td>
<td>The left operands value is moved left by the number of bits specified by the right operand.</td>
<td>a &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>Binary Right Shift</td>
<td>The left operands value is moved right by the number of bits specified by the right operand.</td>
<td>a &gt;&gt; 2</td>
</tr>
</tbody>
</table>

<h2>Logical Operators</h2>

<p>In computer science,&nbsp;<em>logical values;</em> are also known as&nbsp;<em>Boolean values</em>. These values are in Ruby start with lowercase: { true, false }. In Python these values start with uppercase {True, False}.  In Ruby the "true" value is an instance of a special class: TrueClass while "false" value is an instance of FalseClass. There are also two constants: {TRUE, FALSE} that are deprecated.</p>

<p>Several operators have a&nbsp;<em><b>Boolean</b></em>&nbsp;result. These operators can be combined to create logical expressions: "comparison operators", "Boolean operators" and "relation operators". Together they are called "<em>logical operators</em>" in this tutorial since they all produce true or false result.</p>


<h3>Boolean Operators</h3>

<p>Boolean operators deal with Logical values. It can be used also to combine smaller logical expressions into larger expressions. These operators produce Boolean results: true or false</p>

<p class="alert alert-warning"><b>Warning:</b>
In Ruby you should use operators: { &amp;&amp;, ||, ! } for Boolean expressions. 
Alternative operators {and, or, not} are used only in special occasions. 
Keywords {and, or, not} are available for used with "<em>control flow</em>" statements. 
Apparent the are the same, but the behavior is different due to operator precedence.</p>

<table class="table table-bordered table-striped table-dark" >
<thead>
<tr>
<th>symbol</th>
<th>keyword</th>
<th>significance</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>and</td>
<td>Logical AND operator</td>
</tr>
<tr>
<td>||</td>
<td>or</td>
<td>Logical OR operator</td>
</tr>
<tr>
<td>!</td>
<td>not</td>
<td>Logucal NOT operator</td>
</tr>
</tbody>
</table>

<p>The table of truth for Ruby operators:</p>

<table class="table table-bordered table-striped table-dark" >
<tbody>
<tr>
<th>A</th>
<th>B</th>
<th>!A</th>
<th>!B</th>
<th>A || B</th>
<th>A &amp;&amp; B</th>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
</tbody>
</table>
<hr>

<h3>Comparison Operators</h3>

<p>A comparison operator can be used to compare two values. 
Usually values are numeric but can be also strings or objects.
These operators produce a Boolean result.
</p>

<table class="table table-bordered table-dark">
<tbody>
<tr>
<th>Symbol</th>
<th>Description</th>
<th>Expression</th>
<th>Result</th>
</tr>
<tr>
<td rowspan="3">==</td>
<td rowspan="3">equal to</td>
<td>x == 8</td>
<td>False</td>
</tr>
<tr>
<td>x == 5</td>
<td>True</td>
</tr>
<tr>
<td>x == "5"</td>
<td>False</td>
</tr>
<tr>
<td>!=</td>
<td>not equal</td>
<td>x != 8</td>
<td>True</td>
</tr>
<tr>
<td>&gt;</td>
<td>greater than</td>
<td>x &gt; 8</td>
<td>False</td>
</tr>
<tr>
<td>&lt;</td>
<td>less than</td>
<td>x &lt; 8</td>
<td>True</td>
</tr>
<tr>
<td>&gt;=</td>
<td>greater than or equal to</td>
<td>x &gt;= 8</td>
<td>False</td>
</tr>
<tr>
<td>&lt;=</td>
<td>less than or equal to</td>
<td>x &lt;= 8</td>
<td>True</td>
</tr>
<tr>
<tr>
<td>&lt;=&gt;</td>
<td>combined comparison</td>
<td>0 &lt;=&gt; 1 # -1</td>
<td>True</td>
</tr>
</tbody>
</table>

<h4>Example:</h4>

<p>In the next example we initialize value x, called "test fixture" and 
we use this value to create relation x==5 to demonstrate how a relation produce a Boolean response.
In the next table, we use variable x = 5 to demonstrate various comparison expressions.

</p>
<pre><code class="language-ruby">#example of identity relation
x = 5    # create a test fixture
puts x;  # check x value
puts "is x equal to 5? ", x == 5;
</code></pre>   

<h4>Examples:</h4>
<p>In next example, we use operators: { &lt; , &gt;, &lt;=, &gt;=, ==, !=, &lt;=&gt;}</p>
<pre><code class="language-ruby line-numbers"># equal and different
1 == 0 # false
1 != 0 # true

# less than and greater than
4 &lt; 5 # true
5 &gt; 4 # true

# greater then or equal to
0 &gt;= 0 #true
0 &gt;= 1 #false

# less then or equal to
1 &lt;= 1 #true
1 &lt;= 0 #true

# combined comparison
0 &lt;=&gt; 1 # -1
1 &lt;=&gt; 0 # 0
1 &lt;=&gt; 0 # 1
</code></pre>

<h3>Relation Operators</h3>

<p>Relation operators can verify if there is any relation between a literal constant or variable and a collection.
This operator also produce a Boolean result.
</p>

<table class="table table-bordered table-dark">
<tr>
<th>Symbol</th>
<th>Description</th>
<th>Expression</th>
<th>Result</th>
</tr>
<tr>
<td>===</td>
<td>range include operator</td>
<td>(1..5) === 5</td>
<td>True</td>
</tr>
</table>

<h4>Example:</h4>

<p>In this example we verify membership of collections</p>

<pre><code class="language-ruby line-numbers"># range include operator
(1..5)  === 5 # true
(1...5) === 5 # false

# range exclusion expression
!((1..5)  === 3) # false</code></pre>

<div class="alert alert-danger"><b>Note:</b> There is no exclusion operator "!==". If you want to negate result of relation operator "===" you can use round brackets !(expression) to negate the result.</div>

<hr>

<p><b>Read next:</b>
<a href="variables.html">Variables</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>


</div>
</body>
</html>