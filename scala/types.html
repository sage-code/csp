<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Understending Scala type system.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, scala, syntax, data, types, type, system">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Scala Types</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="../prism.css">
  <script src="../prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>  
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</div>
    

<hr>

<h1>Scala Types</h1>

<div class="alert alert-secondary shadow-sm">
Scala is a strongly typed language, similar to Java and C++. Unlike for Java there are no native types in Scala. All data types are part of <em>Scala Unified Type</em> hierarchy. The root of all types is called "Any" and is a Class. Therefore in Scala everyting is an Object.
</div>


<div align="center">
  <img src="img/ScalaTypes.svg" alt="ScalaTypes" width="720" 
       class="img-fluid protect rounded shadow border" >    
  <p>Type Hierarchy</p>
</div>  

<h4>Notes:</h4>

<ul>
<li>The type: "Any" is the root of all types;</li>
<li>The type: "AnyVal" is supertipe of all value types;</li>
<li>The type: "AnyRef" is supertipe of all references;</li>
<li>The type: "Unit" is special, it has one single instance: ();</li>
</ul>

<h2>Nothing and Null</h2>

<p>The <em>"Nothing"</em> is a subtype of all types. There is no value that has type <em>Nothing</em>. A common use is to signal special cases such as a thrown exception, program exit, or an infinite loops.</p>

<p>The <em>"Null"</em> is a subtype of all reference types. It has a single value identified by the keyword literal <em>"null"</em>. Null is provided mostly for interoperability with other JVM languages and should almost never be used in Scala code.</p>

<h2>Type Casting</h2>

<p>Values can be safely casted in a single direction. This is happening automatically and does not require a special syntax. The compiler will not complain if the conversion is safe.</p>

<div align="center">
  <img src="img/TypeConversion.svg" alt="TypeConversion" width="700" 
       class="img-fluid protect rounded shadow border" >    
  <p>Safe Conversion</p>
</div> 

<p><b>Examples:</b><p>

<pre><code class="language-scala line-numbers">//demo for type conversion
val heart: Char = 'â™¥'    // Character
val number: Int = heart  // 2665

// demo for numeric conversion
val x: Long   = 125 // long integer 
val y: Double = x   // 1.25E2
</code></pre>

<h2>Type Properties</h2>

<p>Scala is following Java types. Though scala types are boked values, ultimately these types contain the data that is handled by JVM. And JVM is handling native types. So the underline value of these types have same limits and capacity as the native Java types.</p>

<table class="table table-bordered table-striped table-dark" >
<thead>
<tr>
<th>DATATYPE</th>
<th>DEFAULT VALUE</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>false</td>
<td>true or false (theoretical one byte)</td>
</tr>
<tr>
<td>Byte</td>
<td>0</td>
<td>8 bit signed value. Range:-128 to 127</td>
</tr>
<tr>
<td>Short</td>
<td>0</td>
<td>16 bit signed value. Range:-2<sup>15</sup>&nbsp;to 2<sup>15</sup>-1</td>
</tr>
<tr>
<td>Char</td>
<td>&lsquo;\u000&rsquo;</td>
<td>16 bit unsigned unicode character. Range:0 to 2<sup>16</sup>-1</td>
</tr>
<tr>
<td>Int</td>
<td>0</td>
<td>32 bit signed value. Range:-2<sup>31</sup>&nbsp;to 2<sup>31</sup>-1</td>
</tr>
<tr>
<td>Long</td>
<td>0L</td>
<td>64 bit signed value. Range:-2<sup>63</sup>&nbsp;to 2<sup>63</sup>-1</td>
</tr>
<tr>
<td>Float</td>
<td>0.0F</td>
<td>32 bit IEEE 754 single-Precision float</td>
</tr>
<tr>
<td>Double</td>
<td>0.0D</td>
<td>64 bit IEEE 754 double-Precision float</td>
</tr>
</tbody>
</table>

<h2>Scala Strings</h2>

<p>Scala has a very useful type you can use to define strings. This type has features that makes it more like Ruby strings than Java. When you define a string you use double quotes "...". The String type is used automatically when you declare a string with initial value:</p>

<h4>Examples:</h4>

<pre><code class="language-scala line-numbers">//string declaration demo
val firstName = "Elucian"
val lastName  = "Moise"
val fullName  = firstName + " " + LastName
</code></pre>

<p><b>Note:&nbsp;</b></p> The strings can be concatenated using "+" operator. This operator is polymorphic. It can add numbers to strings, result is of course a concatenation.</p>

<h2>Multiline strings</h2>

<p>Scala has support for multiline strings. As you maybe know this is available in Python but not in Java. To make a multiline string you must use triple quotes: """...""". There is a problem about the indentation that is resolved elegandly using separator "|" after indentation spaces and call method: stripMargin.</p> 

<h4>Example:</h4>

<p>In this example we show a paragraph written in a foreign language called Maj. As you can see the test span several lines and every line starts with vertical "|". Method stripMargin will eliminate this symbol but will preserve new lines.<p> 

<pre><code class="language-scala">//long string declaration demo
val majText = """kaplo la ome sebo lege de vola, no sonu ni moda una Apena 
                |zolu ablo sh volu; sua aripe sonu tro piko sh yc lifu sua 
                |unto piko-boda abo el sola; el Apena, zogu volu ora-vi ipo 
                |Apene no kocu ke Xume siku kh no sonu poso.""".stripMargin
</code></pre>

<h2>String Comparison</h2>

<p>You can compare two strings using regular comparison operators: "==", "&lt;", "&gt;". This feature is very important. Many developers fall into a trap when they do this comparison in Java. Becouse in Java symbol "==" can not be used to compare two strings.</p>

<h4>Example:</h4>

<pre><code class="language-scala">//define 3 strings for testing
val str1 = "this is a test"
val str2 = "this " + "is " + "a " + "test"
val str2 = "this"

// check comparison operators
str1 == str2 // true
str1 > str3  // true

// you can do this same using a method
str1.eqials(str2) //true
</code></pre>


<h2>String Interpolation</h2>

<p>We can use symbol "$" in front of identifiers like ($identifier) or expressions like ${expression} to create a string template that will be resolved at runtime. The expressions will be evalueated and replaced. This is more convenient than string format functions found in Java and Python.</p>

<h4>Example:</h4>

<p>Notice, for string interpolation to work, string is starting with prefix: (s").</p>

<pre><code class="language-scala line-numbers">//interpolation demo
val firstName = "John"
val lastName  = "Doe"
println(s"Name: $firstName $lastName")
println(s"I know math: 2 + 2 = ${2 + 2}")
</code></pre>

<p><b>Output (Scala REPL):</b></p>

<pre class="language-scala">
scala> val firstName = "John"
firstName: String = John

scala> val lastName  = "Doe"
lastName: String = Doe

scala> println(s"Name: $firstName $lastName")
Name: John Doe

scala> println(s"I know math: 2 + 2 = ${2 + 2}")
I know math: 2 + 2 = 4
</pre>

<h2>Touples</h2>

<p>A tuple is a class that enable you to hold different items groupped in the same container. A touple literal is very simple a list of constant literals separated by comma and enclosed in round brackets: (...).</p> 

<pre><code class="language-scala">//define 2 touples
val t2 = (1, 2) 
val t6 = (1, "one", 2, "two", 3, "three")

//using tuple fields
println(t6._1) // 1
println(t6._2) // one

//unpacking tuple into individual values
val (x, y, z) = (1, 2 ,3)

//ignore elements in the middle
val ( s1,_,_,_,_,s6) = t6
</code></pre>

<p><b>Alternative notation:&nbsp;</b>You can use arrow operator: "->" to create a pair of elements as a tuple. This notation is mostly used to define maps. We will check it later when we study collections.</p>

<pre><code class="language-scala">//define 3 touples
val pair1 = 1 -> "one"
val pair2 = 2 -> "two"
val pairs = (pair1, pair2) // touple of touples

//check the results
println(pair1.toString())  // (1,one)
println(pair2.toString())  // (2,two)
println(pairs.toString())  // ((1,one),(2,two))
</code></pre>

<hr>
<p><b>Read next:</b>
<a href="functions.html">Functions</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>