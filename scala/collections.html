<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Understend Scala collections.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, scala, collections, array, map, set">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Scala Collection</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="https://sagecode.net/prism.css">
  <script src="https://sagecode.net/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>  
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>

<h1>Scala Collection</h1>

<div class="alert alert-secondary shadow-sm">
A collection is a group of elements, all having the same type. There are two kind of collections: direct (indexed), or sequential (not indexed). Not all collections have index and direct access. Also some collections are mutable and some other are immutable. Some collections have versions that are both mutable or immutable.
</div>

<p>In Scala, all collections are classes, each extending one trait. Of course they are! When you make a collection you must declare the class and data type of the elements. We will start explaining most used collections in order, as listed below:</p>

<table class="table table-bordered table-striped table-dark" ><thead>
<tr><th>Class	   </th><th>Mutability</th><th>Description</th></tr>
</thead><tbody>                       
<tr><th>List       </th><td>immutable </td><td>linked list, sequence        </td></tr>
<tr><th>Vector	   </th><td>immutable </td><td>indexed sequence             </td></tr>
<tr><th>Range      </th><td>immutable </td><td>ordered sequence of integers </td></tr>
<tr><th>Set	       </th><td>both      </td><td>collection of unque elements </td></tr>
<tr><th>Map	       </th><td>both      </td><td>collection of key/value pairs</td></tr>
<tr><th>ArrayBuffer</th><td>mutable   </td><td>indexed sequence             </td></tr>  
</tbody></table>

<h4>Full Hierarchy</h4>

<p>For curious people next you can study the diagram showing the full herarchy of traits and classes available for representing collections. In real life you will probably never use them all. We will explain only the most useful ones and make some examples.</p>

<div align="center">
  <img src="img/CollectionHierarchy.svg" alt="Collection Hierarchy" width="700" class="img-fluid protect rounded shadow border" >    
  <p>The Hierarchy of Collection Classes</p>
</div>  

<h2>List</h2>

<p>A List is a finite and immutable sequence of elements. It provide constant-time access to its first element and linear time for the rest of the list. Lists have a constant time/cost for adding a new element to the beginning of the list. When the list is short this is a very efficient data structure.</p> 


<h4>Example:</h4>

<pre><code class="language-scala">/* Make a list using companion object */
val days = List("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")
</code></pre>

<p>More: <a href = "https://www.scala-lang.org/api/current/scala/collection/immutable/List.html"
target="_blank" rel="noopener noreferrer nofollow">List API</a></p>

<h2>Vector</h2>

<p>A vector is a new collection type in Scala 2.8. Vectors allow accessing any element in constant time not dependent on the number of elements. The algorithms can access and modify elements of vectors at arbitrary locations, thus they can be more efficient than Lists.</p> 

<h4>Example:</h4>

<pre><code class="language-scala">/* We create two vectors as demo. */
val myVector = Vector(1, 2, 3, 4, 5)
val weekEnd: Vector[String] = Vector("Friday", "Saturday", "Sunday")

/* accessing elements by index */
println(s"weekEnd(0) = ${weekEnd(0)}")
println(s"weekEnd(1) = ${weekEnd(1)}")
println(s"weekEnd(2) = ${weekEnd(2)}")
</code></pre>

<p>More: <a href = "http://www.scala-lang.org/api/current/scala/collection/immutable/Vector.html"
target="_blank" rel="noopener noreferrer nofollow">Vector API</a></p>

<h2>Range</h2>

<p>A Range is an ordered sequence of integers that are equally spaced apart. In mathematics we use square brackets to represent ranges.</p> 


<h4>Example:</h4>

<p>For example: [0, 3] is a range, as is: [4,7) but 7 is excluded. We do not use this notation in programming. Instead, to create a range in Scala, we use the predefined keywords: "to","until" and "by" with limits: min-limit and max-limit.</p>

<pre><code class="language-scala">/* Range expressions: */
0 to 3           // Range(0,1,2,3)  
4 until 7        // Range(4,5,6)  
4 to 10 by 2     // Range(4,6,8,10)
1 until 10 by 3  // Range(1,3,6,9)
</code></pre>

<p>More: <a href = "https://www.scala-lang.org/api/current/scala/collection/immutable/Range.html"
target="_blank" rel="noopener noreferrer nofollow">Range API</a></p>

<h4>Notes:</h4>

<ul>
<li>If you want to create a range that is exclusive of its upper limit, then use the convenience method "until" instead of "to";</li>
<li>Ranges are efficient, because they can be defined by just three numbers: their start, their end, and the stepping value;</li>
</ul>

<h2>Set</h2>

<p>Sets are iterable collections that contain unique elements. There are two versions available: <em>immutable</em> &amp; <em>mutable</em> sets, in different libraries. To create an immutable set we use collection.immutable.Set() for mutable set we use collection.mutable.Set().</p> 

<h4>Example:</h4>

<pre><code class="language-scala">/* Create Set collection: */
val fruit = Set("apple", "orange", "peach", "banana") 
</code></pre>

<h2>Map</h2>


<p>Maps are iterable collections consisting of (key, value) pairs that are actually tuples of two elements. The key can be integer, character or string. To access one element you can use the <em>key</em> like an index.</p> 

<h4>Example:</h4>

<pre><code class="language-scala">/* Create two identical Map collections: */
val thatMap = Map("x" -> 24, "y" -> 25, "z" -> 26)
val thisMap = Map(("x", 24), ("y", 25), ("z", 26))
</code></pre>


<p>More: <a href = "http://www.scala-lang.org/api/current/scala/collection/Map.html"
target="_blank" rel="noopener noreferrer nofollow">Map API</a></p>


<h2>ArrayBuffer</h2>

<p>This is the most popular among Java developers. It has similar methods. When use collections you must import them. That means they are external to your program and not known, until you import them.</p> 

<h4>Example 1:</h4>

<p>In next example we create two ArrayBuffer collections. One is holding integers the other one is holding strings. Both are empyt at initialization time and get populated later with two elements each.</p>

<pre><code class="language-scala line-numbers">/* Using ArrayBuffer require import */
import scala.collection.mutable.ArrayBuffer

//create empty Arrays:
val ints = ArrayBuffer[Int]()
val names = ArrayBuffer[String]()

//create new elements 
ints += 1
ints += 2

//create new elements 
names += "scala"
names += "test"
</code></pre>

<h4>Example 2:</h4>

<p>When you create a collection, you can use arguments to initialize all the elements. In next example we create ArrayBuffer collection: "nums" with 3 initial elements, then we add other elements and then remove some.</p>

<pre><code class="language-scala line-numbers">/* Using type inference: */
val nums = ArrayBuffer(1, 2, 3) //initialized

// add multiple elements in one statement
nums += 5 += 6

// add multiple elements from another collection
nums ++= List(7, 8, 9)

// remove one element
nums -= 9

// remove multiple elements
nums -= 7 -= 8

// remove multiple elements using another collection
nums --= Array(5, 6)
</code></pre>
<!-- todo: methods for ArrayBuffer-->

<p>More: <a href = "https://www.scala-lang.org/api/current/scala/collection/mutable/ArrayBuffer.html"
target="_blank" rel="noopener noreferrer nofollow">ArrayBuffer API</a></p>

<!-- work in progress-->

<p><b>Note:&nbsp;</b>That's all I can say about collections for now. In the future is possible I will return here an continue my research. For deep learning you alwais have the API where you can dig in for more information. You will find some more examples in next page. </p>

<p>Study full: <a href = "https://www.scala-lang.org/docu/files/collections-api/collections_49.html"
target="_blank" rel="noopener noreferrer nofollow">Collections API</a></p>


<hr>
<p><b>Read next:</b>
<a href="control.html">Control Flow</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>