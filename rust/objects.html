<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Object oriented Rust implementation. Rust OOP.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="rust, oop, class, syntax, methods, objects, classes">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Rust OOP</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="https://sagecode.net/prism.css">
  <script src="https://sagecode.net/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"></a>
    </div>  
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>


<h1>Rust Objects</h1>

<div class="alert alert-secondary">Object-Oriented Programming (OOP) is a programming paradigm centered around the idea of objects, which are a combination of data and related methods. OOP allows developers to write code that is modular, re-usable, and easy to maintain.</div>

<h4>Page Bookmarks</h4>
<hr>
<nav><ul>
    <li><a href="#abstraction">Abstraction</a></li>
    <li><a href="#encapsulation">Encapsulation</a></li>
    <li><a href="#inheritance">Inheritance</a></li>
    <li><a href="#polymorphism">Polymorphism</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
</ul>
</nav>
<hr>

<h2 id="abstraction">Abstraction</h2>

<p>Rust's implementation of Object-Oriented  concepts provides a way for developers to define data structures that are encapsulated and have their own behavior (methods) and traits can be used as interfaces to define behaviors, similar to inheritance.</p> 

<p>Generics are used to create polymorphic functions and data structures, while trait objects provide dynamic dispatch, allowing for object-oriented code to run in Rust safely and effectively.</p>


<h2 id="encapsulation">Encapsulation</h2>

<p>Encapsulation is a fundamental principle of Object-Oriented Programming that refers to the bundling of data and methods into a single unit. In Rust, this is achieved using a struct which combines data and methods. The struct keyword in Rust is used to define a struct. Here's an example:</p>

<pre><code class="language-rust line-numbers">rust
struct Person {
    name: String,
    age: u32,
}
</code></pre>

<p>In this example, we define a struct called "Person" with two fields: "name" of type "String" and "age" of type "u32". These fields are encapsulated within the "Person" struct.</p>

<h2 id="inheritance">Inheritance</h2>

<p>Inheritance is another principle of Object-Oriented Programming that allows for the creation of a new class, called a subclass, that is a modified version of an existing class, called a superclass. Rust does not natively support inheritance, but this can be achieved using traits. Traits are similar to interfaces in other languages and define a set of methods that a type must implement. Here's an example:</p>

<pre><code class="language-rust line-numbers">
trait Animal {
    fn speak(&self) -&gt; &amp;str;
}

struct Dog {
    name: String,
}

impl Animal for Dog {
    fn speak(&self) -&gt; &str {
        "woof"
    }
}
</code></pre>

<p>In this example, we define a trait called "Animal" with a method called "speak". We then define a struct called "Dog" with a field called "name". We implement the "Animal" trait for the "Dog" struct, which means we must implement the "speak" method for the "Dog" struct. In this case, the "speak" method returns the string "woof".</p>

<h2 id="polymorphism">Polymorphism</h2>

<p>Polymorphism is a principle of Object-Oriented Programming that allows different objects to be treated as if they were the same type. Rust supports polymorphism through both static and dynamic dispatch.
</p>

<p><em>Static dispatch</em> is accomplished through the use of generics. Here is an example:</p>

<pre><code class="language-rust line-numbers">
struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
    
    fn get_x(&self) -&gt; &T {
        &self.x
    }
    
    fn get_y(&self) -&gt; &T {
        &self.y
    }
}
</code></pre>

<p>In this example, we define a struct called "Pair" that takes a type parameter "T". We have methods that allow us to retrieve the "x" and "y" fields of the "Pair" struct. Because we defined our methods on the "Pair&lt;T&gt;" type, we can create a "Pair" of any type "T" and access the same methods.</p>

<p><em>Dynamic dispatch</em> is accomplished through the use of trait objects. Here is an example:</p>

<pre><code class="language-rust line-numbers">
trait Shape {
    fn area(&self) -&gt; f64;
}

struct Circle {
    radius: f64,
}

impl Shape for Circle {
    fn area(&self) -&gt; f64 {
        self.radius * self.radius * std::f64::consts::PI
    }
}

struct Square {
    length: f64,
}

impl Shape for Square {
    fn area(&self) -&gt; f64 {
        self.length * self.length
    }
}

fn get_area(shape: &dyn Shape) -&gt; f64 {
    shape.area()
}
</code></pre>

<p>In this example, we define a trait called "Shape" with a method called "area". We then define two structs: "Circle" and "Square", both of which implement the "Shape" trait. We define a function called "get_area" that takes a reference to a value that implements the "Shape" trait. We can then pass in a "Circle" or "Square" to the "get_area" function, and it will call the "area" method based on the type of the object passed in, providing dynamic dispatch.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Overall, while Rust is not a pure Object-Oriented Programming language, it does provide support for many of the fundamental principles of Object-Oriented Programming through features such as structs, traits, generics, and trait objects. By leveraging these language features, Rust programmers can create code that is modular, reusable, and easy to read and maintain.</p>


<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="modules.html">Modules</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>