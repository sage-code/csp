<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Learn the basic types in Rust.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="rust, primitive, basic, types">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Basic Types</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="https://sagecode.net/prism.css">
  <script src="https://sagecode.net/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"></a>
    </div>  
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>


<h1>Basic Types</h1>


<div class="alert alert-secondary shadow-sm">
Rust is a strongly typed programming language. That means after a variable is declared its data type remain the same during program execution. All other types are derived from basic types.
</div>


<h4>Page Bookmarks</h4>
<hr>

<ul>
  <li><a href="#primitive">Primitive types</a></li>  
  <li><a href="#constants">Constants</a></li>  
  <li><a href="#variables">Variables</a></li>  
  <li><a href="#pointers">Pointers</a></li>  
  <li><a href="#borrowing">Borrowing</a></li> 
  <li><a href="#refcount">Refference counting</a></li> 
  <li><a href="#inference">Type inference</a></li> 
  <li><a href="#inference">Type coercion</a></li> 
</ul>

<hr>

<p><b>Note: </b>Data types are important in Rust because they determine how data can be stored and manipulated. Using types reduce probability to have runtime errors and make more robust applications by using type checking.</p>

<h2><a id="primitive"></a>Primitive Types</h2>

<p>In Rust we have 3 <em>primitive</em> types. Signed, unsigned and floating precision numbers. Each type specify the number of bits, so it is much more easy to remember the type notation than in C language.</p>

<table class="table table-striped table-bordered table-dark">
  <tr>
    <th>Data Type</th>
    <th>Bytes</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>i8</code></td>
    <td>1</td>
    <td>Signed 8-bit integer</td>
  </tr>
  <tr>
    <td><code>i16</code></td>
    <td>2</td>
    <td>Signed 16-bit integer</td>
  </tr>
  <tr>
    <td><code>i32</code></td>
    <td>4</td>
    <td>Signed 32-bit integer</td>
  </tr>
  <tr>
    <td><code>i64</code></td>
    <td>8</td>
    <td>Signed 64-bit integer</td>
  </tr>
  <tr>
    <td><code>i128</code></td>
    <td>16</td>
    <td>Signed 128-bit integer</td>
  </tr>
  <tr>
    <td><code>isize</code></td>
    <td>*</td>
    <td>Signed pointer-sized integer (can be 32 or 64 bits)</td>
  </tr>
  <tr>
    <td><code>u8</code></td>
    <td>1</td>
    <td>Unsigned 8-bit integer</td>
  </tr>
  <tr>
    <td><code>u16</code></td>
    <td>2</td>
    <td>Unsigned 16-bit integer</td>
  </tr>
  <tr>
    <td><code>u32</code></td>
    <td>4</td>
    <td>Unsigned 32-bit integer</td>
  </tr>
  <tr>
    <td><code>u64</code></td>
    <td>8</td>
    <td>Unsigned 64-bit integer</td>
  </tr>
  <tr>
    <td><code>u128</code></td>
    <td>16</td>
    <td>Unsigned 128-bit integer</td>
  </tr>
  <tr>
    <td><code>usize</code></td>
    <td>*</td>
    <td>Unsigned pointer-sized integer (can be 32 or 64 bits)</td>
  </tr>
  <tr>
    <td><code>f32</code></td>
    <td>4</td>
    <td>32-bit floating point number</td>
  </tr>
  <tr>
    <td><code>f64</code></td>
    <td>8</td>
    <td>64-bit floating point number</td>
  </tr>
  <tr>
    <td><code>char</code></td>
    <td>4</td>
    <td>Unicode scalar value (4 bytes)</td>
  </tr>
  <tr>
    <td><code>bool</code></td>
    <td>1</td>
    <td>Boolean value (<code>true</code> or <code>false</code>)</td>
  </tr>
  <tr>
    <td><code>()</code></td>
    <td>0</td>
    <td>The empty tuple type, also known as "unit"</td>
  </tr>
</table>

<p>(*) = platform-dependent</p>

<p>In Rust "i" numbers are signed integers. "u" numbers are unsigned. "f" numbers are floating point numbers. Variable size data types: isize and usize depends on machine architecture 32 or 64 bits.</p>

<h4>Boolean types:</h4>

<p>In Rust the Boolean values are <b><em>true</em></b> and <b><em>false</em></b> like in Python and Ruby. The operators for Boolean expressions are: {&amp;&amp;,||,!}.</p>

<h4>Character types: </h4>

<p>In Rust characters are Unicode not ASCII and occupy 4 bytes not 1 byte. A character is enclosed in single quotes like: {'0','1'....'a','b',.... '&pi;','&alpha;','&beta;',... '&omega;'}</p>

<h2><a id="constants"></a>Constants</h2>

<p>Constants are values that cannot be changed. They are declared using the <code>const</code> keyword.</p>

<p>For example:</p>
<pre><code class="language-rust">
  const pi: f64 = 3.14159265358979323846;
</code></pre>

<p>Constants can be initialized with any expression that evaluates to a constant value. For example:</p>
<pre><code class="language-rust">
  const pi: f64 = 3.14 + 0.00159265358979323846;
</code></pre>

<p>Constants can be used in any expression. For example:</p>

<pre><code class="language-rust">
  let r = pi * 2;
</code></pre>
<p>Constants can also be used in function definitions. For example:</p>

<pre><code class="language-rust">
  fn circumference(r: f64) -> f64 {
    2 * pi * r
  }
</code></pre>

<p>Constants are immutable, which means that their value cannot be changed once they have been initialized. For example:</p>

<pre><code class="language-rust">
  pi = 3.141593; // This will not compile
</code></pre>

<p>Constants are also thread-safe, which means that they can be accessed from multiple threads without any synchronization.</p>

<p>Constants are a useful way to store values that will not change throughout the lifetime of a program. They can also be used to create functions that are thread-safe and immutable.</p>


<h2><a id="variables"></a>Variables</h2>

<p>In Rust you must declare data type to create a variable using symbol ":">  and keyword <em>let</em> Variables are immutable in Rust unless you specify otherwise. Global variables can be defined using keyword <em>static</em> or <em>const</em>.</p>

<h4>Example:</h4>
<pre><code class="language-rust line-numbers">/* demo to declare a static variable */
static TEST: 
i32 = 10; // global variable

fn main() {
  let x = TEST + 1;        // use TEST in expression
  println!("TEST = {}",x); // printing the result
}</code></pre>

<p><b>Notes: </b></p>
<ul>
<li>rust is using type inference the best it can to detect type for "x"</li>
<li>you can declare a variable and set initial value for it in a single statement</li>
</ul>

<h2>Expressions</h2>

<p>Rust is using infix notation to create expressions. An expression is created using variables, constants and literals separated by operators. In previous example we use expression: TEST+1  to calculate initial value for x. The result of expressions can be captured into a new variable using assign symbol "=". </p>

<p>You can create larger expressions from small expressions using parenthesis and operators. The order of operations is important. Operators { *,  / } have higher precedence than { +, &ndash; }.</p>

<h4>Example:</h4>
<pre><code class="language-rust">(x + y) / 2 &lt; (x + y)</code></pre>

<h4>Notes:</h4>
<ul>
<li>Previous expressions will evaluate <em>true </em>if x and y are both positive,</li>
<li>Relation operator "&lt;" has lower precedence than arithmetic operator "/",</li>
<li>It is a good practice to use spaces to separate operators of literals.</li>
</ul>


<h2><a id="pointers"></a>Pointers in Rust</h2>

<p>In Rust, a pointer is a variable that stores the address of another variable in memory. Pointers are useful for interacting with data and memory at a lower level.</p>

<p>Rust has two operators for pointers:</p>

<ul>
  <li><code>&amp;</code>, a reference operator that creates a reference to a value</li>
  <li><code>*</code>, a dereference operator that accesses the value at the address stored in a pointer</li>
</ul>

<p>Here's an example:</p>

<pre><code class="language-rust line-numbers">
fn main() {
    let mut number = 5;
    println!("The number is {}", number);

    let pointer_to_number = &amp;mut number;
    *pointer_to_number += 5;
    println!("The new number is {}", number);
}
</code></pre>

<p>In this example, we define a variable <code>number</code> and set its value to <code>5</code>. We then create a mutable reference to <code>number</code> using the <code>&amp;mut</code> operator and store the reference in <code>pointer_to_number</code>.</p>

<p>We can access the value of <code>number</code> using the <code>*</code> operator and modify it by adding <code>5</code> through <code>pointer_to_number</code>.</p>

<p>Finally, we print the modified value of <code>number</code>.</p>

<p>Pointers in Rust help prevent common memory-related errors such as null references and memory leaks. Rust's borrow checker also ensures that pointers are used safely by ensuring that there is no data race or concurrent access to mutable data.</p>


<h2><a id="borrowing"></a>Borrowing System</h2>

<p>Rust's borrowing system is a set of rules and checks that ensure safe and efficient memory usage. The system is designed to address common memory-related errors such as null references, dangling pointers, data races, and memory leaks.</p>

<p>The core concept of Rust's borrowing system is ownership. In Rust, every value has an owner, which is responsible for allocating and deallocating its memory. The ownership of a value can be transferred to other variables using move semantics or shared through references.</p>

<p>Rust has two kinds of references: immutable references and mutable references. Immutable references, denoted by the <code>&amp;</code> operator, allow read-only access to the referenced value. Mutable references, denoted by the <code>&amp;mut</code> operator, allow both read and write access to the referenced value but with the constraint that there is only one mutable reference at a time.</p>

<p>The borrowing system enforces a set of rules to prevent memory-related errors and ensure safe concurrency:</p>

<ul>
  <li>A value can have only one mutable reference at a time or multiple immutable references at a time.</li>
  <li>A mutable reference cannot coexist with any other reference.</li>
  <li>References must follow the borrowing rules in their respective scopes.</li>
  <li>References must not outlive the value they reference.</li>
  <li>The borrow checker enforces these rules at compile-time to prevent errors at runtime.</li>
</ul>

<p>Here's an example:</p>

<pre><code class="language-rust line-numbers">
fn main() {
    let mut number = 5;
    let reference_to_number = &amp;number;
    let another_reference_to_number = &amp;number;
    println!("The number is {}", number);

    let mutable_reference_to_number = &amp;mut number;
    *mutable_reference_to_number += 5;
    println!("The new number is {}", number);
}
</code></pre>

<p>In this example, we create an immutable reference to <code>number</code> using the <code>&amp;</code> operator and store the reference in <code>reference_to_number</code>. We then create another immutable reference to <code>number</code> called <code>another_reference_to_number</code>.</p>

<p>Because there are no mutable references to <code>number</code>, we can still modify its value through a mutable reference <code>mutable_reference_to_number</code>.</p>

<p>Rust's borrowing system helps prevent common memory-related errors by ensuring that data is used in a safe and efficient manner. It requires that mutable access to data is limited to a single owner at a given time and that shared access is immutable.</p>


<h2><a id="refcount"></a>Reference Counting</h2>

<p>Reference counting is a memory management technique that allows shared ownership of resources by keeping track of the number of references to that resource. In Rust, reference counting is implemented using the <code>Rc</code> smart pointer.</p>

<p>The <code>Rc</code> smart pointer allows multiple immutable references to the same value, and only when all references to a value have been dropped, the value is deallocated. This ensures that the value is available as long as any reference to it exists.</p>

<pre><code class="language-rust line-numbers">
use std::rc::Rc;

struct Person {
  name: String,
  age: u8,
}

fn main() {
  let person_rc1 = Rc::new(Person {
    name: String::from("Alice"),
    age: 25,
  });

  {
    let person_rc2 = person_rc1.clone();
    println!(
      "Person 1: {:#?}, Person 2: {:#?}",
      person_rc1, person_rc2
    );
  }

  println!("Person: {:#?}", person_rc1);
}
</code></pre>

<p>In this example, we define a <code>Person</code> struct that contains a name and an age field. We then create an <code>Rc</code> instance of the <code>Person</code> struct using the <code>Rc::new()</code> method.</p>

<p>We then create a second <code>Rc</code> instance of the <code>Person</code> struct, <code>person_rc2</code>, by calling the <code>.clone()</code> method on the first instance, <code>person_rc1</code>.</p>

<p>After printing both <code>Rc</code> objects, we see that they are identical. This is because they refer to the same underlying <code>Person</code> struct. We then drop the second <code>Rc</code> instance, and we see that the first <code>Rc</code> instance continues to exist, preserving the <code>Person</code> instance's data.</p>

<p>The <code>Rc</code> smart pointer is useful when working with graphs or other data structures that require shared ownership, and manual memory management is not feasible. However, the <code>Rc</code> smart pointer introduces runtime overhead for reference counting, which can affect performance. </p>

<h2><a id="inference"></a>Type Inference</h2>

<p>Rust is a statically-typed language, which means that variables are given a specific type at compile-time, and the type of the variable cannot change throughout the program's execution. However, Rust also provides type inference, which allows the compiler to automatically determine the types of variables based on their usage.</p>

<p>For example, when a variable is assigned a value, the Rust compiler analyzes the value's type and uses that information to determine the variable's type. Here's an example:</p>

<pre><code class="language-rust line-numbers">
fn main() {
  let x = 5; // x is inferred to be of type i32
  let y = 3.14; // y is inferred to be of type f64

  let sum = x + y; // compiler error: cannot add f64 and i32
}
</code></pre>

<p>In this example, the variable <code>x</code> is assigned the value <code>5</code>, which the Rust compiler infers to be of type <code>i32</code>. Similarly, the variable <code>y</code> is assigned the value <code>3.14</code>, which the Rust compiler infers to be of type <code>f64</code>.</p>

<p>However, the Rust compiler will not automatically convert types or allow for mismatched types. In the example above, the compiler will produce an error because <code>x</code> and <code>y</code> have different types, and cannot be added together.</p>

<p>While Rust's type inference is powerful, it's important to note that it can make code less readable if used improperly. Explicitly specifying types, even when the Rust compiler can infer them, can make code easier to understand and maintain.</p>

<pre><code class="language-rust line-numbers">
fn main() {
  let x: i32 = 5; // x is explicitly set to type i32
  let y: f64 = 3.14; // y is explicitly set to type f64

  // let's use type cast with operator "as"
  let sum = x as f64 + y; // the addition works 
}
</code></pre>

<p>In this modified example, the types of <code>x</code> and <code>y</code> are explicitly set, which makes it more apparent what the types are, and prevents errors from occurring due to type inference.</p>

<h2><a id="coercion"></a>Type coercion</h2>

<p>Type coercion in Rust is the automatic conversion of one type of data to another type of data. Rust allows for basic type coercion to occur in certain situations, such as when converting a signed integer to an unsigned integer of the same or larger size, or when converting a float to an integer.</p>

<p>Here's an example where coercion occurs:</p>

<pre><code class="language-rust line-numbers">fn main() {
    let x: u32 = 42;
    let y: i64 = x as i64; // x is coerced from u32 to i64
    println!("x: {}, y: {}", x, y);
}
</code></pre>

<p>In this example, the variable <code>x</code> is assigned the value <code>42</code>, which Rust infers to be of type <code>u32</code>. The variable <code>y</code> is assigned the value of <code>x</code> after it is coerced to type <code>i64</code>. Rust allows for this coercion because <code>i64</code> can store any value that <code>u32</code> can store, so there is no risk of data loss.</p>

<p>However, it's worth noting that coercion can also have side effects that may not be immediately apparent. For example, coercing a float to an integer will cause the float's value to be truncated, which can lead to data loss.</p>

<p>Here is a short example that demonstrates this:</p>

<pre><code class="language-rust line-numbers">fn main() {
    let x: f32 = 3.14;
    let y: i32 = x as i32; // x is coerced to i32
    println!("x: {}, y: {}", x, y);
}
</code></pre>

<p>In this example, the variable <code>x</code> is assigned the value <code>3.14</code>, which Rust infers to be of type <code>f32</code>. The variable <code>y</code> is assigned the value of <code>x</code> after it is coerced to type <code>i32</code>. Because <code>i32</code> cannot store decimal values, the decimal portion of <code>x</code> is truncated, resulting in a value of <code>3</code> for <code>y</code>.</p>

<p>Overall, type coercion can be a useful feature in Rust, but should be used judiciously and with an awareness of the potential side effects.</p>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="composite.html">Composite Types</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>