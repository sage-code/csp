<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Template page for tutorials.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="rust, syntax">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Rust Syntax</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="../prism.css">
  <script src="../prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">

<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>


<h1>Rust Syntax</h1>

<div class="alert alert-secondary shadow-sm">Rust is a curly braced free form language. It has similar syntax rules as C language. Basic syntax elements may be very familiar to you if you have study C or any other curly braced language.</div>

<h4>Page Bookmarks</h4>

<nav><ul>
   <li><a href="#rules">Syntax Rules</a></li>
   <li><a href="#basic">Basic Elements</a></li>
   <li><a href="#variables">Variables</a></li>
   <li><a href="#public">Public Elements</a></li>
   <li><a href="#operators">Operators</a></li>
   <li><a href="#delimiters">Delimiters</a></li>
   <li><a href="#keywords">Keywords</a></li>
</ul></nav>


<h2 id="rules">Syntax Rules</h2>

<ul>
<li>Rust is statement oriented language;</li>
<li>A block of code can contain one or more statements;</li>
<li>A block of code is enclosed in curly braces "{ ... }";</li>
<li>End of statement is mark by semicolon ";" like in C;</li>
<li>Rust is case sensitive. Most keywords are lowercase.</li>
</ul>

<div><b>Example:</b></div>

<pre><code class="language-rust line-numbers">/* program entry point */
fn main() {
    println!("Hello, world!"); //macro
}
</code></pre>

<p><b>Notes:</b> In this example "fn" is a keyword that define a function. Notation println!() represent a "macro" not a method or function as you may think. Symbol "!" is used to signal that we use a macro that we can call like we call a function.</p>

<h2 id="basic">Basic Elements</h2>

<p>There is no better time than now to introduce you the basic concepts and notations of Rust syntax.
We will show you on example then we make notes to explain the concept. We explain them as simple as possible so you can learn Rust as your first programming language.</p>

<h3>Comments</h3>

<ul>
<li>Single line Comments start with two slashes //; </li>
<li>Block comments is enclosed using two symbols: /*... */;</li>
<li>Notation "/** ... */ " is recognized as documentation;</li>
</ul>

<h3>Code Block</h3>

<p>In Rust there is a concept of <em>code block</em>. It is a compact region of code separated by squiggly brackets: {....}. In other languages we start a block using "begin" and terminate with "end" keywords. Having brackets used as block of code makes Rust a little bit harder to understand, but we know how to use spaces and new lines to organize our code.</p>


<h3>Indentation</h3>
<p>In Rust the indentation is not relevant but recommended. What is relevant is that we can have nested blocks of code. The outer block can contain one or more inner blocks. Each block of code define a local scope.</p>

<h2 id="variables">Variables</h2>

<p>The variable declaration in Rust is done using keyword "let" and symbol "=". Once a variable is initialized we call this "binding". So a variable is bound to it's value. A variable that is not bound can't be used. To declare a type for a variable we use symbol ":" after the variable name.</p>

<p>A variable is an identifier or a name that can start with "_" or any alphabetic character but not a special character or a number. So this is almost like any other language.To make a variable mutable we declare it using additional keyword "mut". If you forget this, your variable is actually a constant.</p>

<h4>Examples:</h4>
<pre><code class="language-rust line-numbers">/* define variables */
let x: i32 = 5;
let mut y: i32 = 10;
y = 15; //now we can use assignment
x = 15; //this will not work since x is immutable</code></pre>

<hr>

<div class = "alert alert-info">The assignment operator "=" works only with variables that are mutable and bound to initial value. In this case we can change the value of the variable. So you see there is a difference between "let" that initialize a variable and "=" that assign a value to a variable.</div>

<h2 id="public">Public Elements</h2>

<p>The following conventions are used in Rust for public elements:</p>

<ul>
  <li>Public elements should be named in CamelCase.</li>
  <li>Public elements should be documented with a comment that explains what the element does.</li>
  <li>Public elements should be exported from the module that contains them.</li>
  <li>Public elements should be tested to make sure they work as expected.</li>
  <li>Public elements are created with acckesor keyword "pub".</li>
</ul>

<p>Here is an example of a public element that follows these conventions:</p>
<pre><code class="language-rust line-numbers">
pub struct MyStruct {
    // Public field
}

// Public method
impl MyStruct {
    pub fn do_something(&self) {
        // Do something
    }
}
</code></pre>

<h2 id="operators">Operators</h2>

<p>Rust has ASCII operators. Most operators are single character. Some operators are groups of two characters or 3 characters side by side, with no space between them.</p>

<h3>Assign Operators</h3>

<p>Assign operators are used in statements, to create new value for a variable. Some operators modify the variable. These are called modifiers.</p>

<table class="table table-bordered table-striped table-dark" >
  <thead>
    <tr>
      <th>Operator</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>=</code></td>
      <td>Assigns the value on the right to the variable on the left.</td>
    </tr>
    <tr>
      <td><code>+=</code></td>
      <td>Assigns the value on the right to the variable on the left, and then adds the value on the right to the variable.</td>
    </tr>
    <tr>
      <td><code>-=</code></td>
      <td>Assigns the value on the right to the variable on the left, and then subtracts the value on the right from the variable.</td>
    </tr>
    <tr>
      <td><code>*=</code></td>
      <td>Assigns the value on the right to the variable on the left, and then multiplies the value on the right by the variable.</td>
    </tr>
    <tr>
      <td><code>/=</code></td>
      <td>Assigns the value on the right to the variable on the left, and then divides the value on the right by the variable.</td>
    </tr>
    <tr>
      <td><code>%=</code></td>
      <td>Assigns the value on the right to the variable on the left, and then performs the modulo operation on the value on the right and the variable.</td>
    </tr>
    <tr>
      <td><code>&lt;&lt;=</code></td>
      <td>Assigns the value on the right to the variable on the left, and then shifts the value on the right by the number of bits specified on the left.</td>
    </tr>
    <tr>
      <td><code>&gt;&gt;=</code></td>
      <td>Assigns the value on the right to the variable on the left, and then shifts the value on the right by the number of bits specified on the left, but in the reverse direction.</td>
    </tr>
    <tr>
      <td><code>&gt;&gt;=</code></td>
      <td>Assigns the value on the right to the variable on the left, and then shifts the value on the right by the number of bits specified on the left, but in the right direction.</td>
    </tr>
  </tbody>
</table>

<h3>Numeric Operators</h3>

<p>Numeric operators are usually binary. Require left and right operands. In expressions, operators have priority. Multiplication and division first, the addition and subtraction.</p>

<table class="table table-bordered table-striped table-dark" >
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Example</th>
  </tr>
  <tr>
    <td>+</td>
    <td>Addition</td>
    <td>1 + 2 = 3</td>
  </tr>
  <tr>
    <td>-</td>
    <td>Subtraction</td>
    <td>3 - 1 = 2</td>
  </tr>
  <tr>
    <td>*</td>
    <td>Multiplication</td>
    <td>2 * 3 = 6</td>
  </tr>
  <tr>
    <td>/</td>
    <td>Division</td>
    <td>6 / 2 = 3</td>
  </tr>
  <tr>
    <td>%</td>
    <td>Modulus</td>
    <td>6 % 2 = 0</td>
  </tr>
  <tr>
    <td>&lt;&lt;</td>
    <td>Left shift</td>
    <td>1 &lt;&lt; 2 = 4</td>
  </tr>
  <tr>
    <td>&gt;&gt;</td>
    <td>Right shift</td>
    <td>2 &gt;&gt; 1 = 1</td>
  </tr>
  <tr>
    <td>&and;</td>
    <td>bitwise AND</td>
    <td>1 & 2 = 0</td>
  </tr>
  <tr>
    <td>|</td>
    <td>bitwise OR</td>
    <td>1 | 2 = 3</td>
  </tr>
  <tr>
    <td>~</td>
    <td>bitwise NOT</td>
    <td>~1 = -2</td>
  </tr>
  <tr>
    <td>^</td>
    <td>bitwise XOR</td>
    <td>1 ^ 0 = 0</td>
  </tr>
</table>
<!-- work in progress-->

<h3>Logic operators</h3>

<p>Next, you can review all the logic and relation operators of Rust language with expression example. All these expressions are called Boolean expressions.</p>

<table class="table table-bordered table-striped table-dark" >
  <thead>
    <tr>
      <th>Operator</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>&&</code></td>
      <td>Logical AND</td>
      <td>a && b</td>
    </tr>
    <tr>
      <td><code>||</code></td>
      <td>Logical OR</td>
      <td>a || b</td>
    </tr>
    <tr>
      <td><code>!</code></td>
      <td>Logical NOT</td>
      <td>!a</td>
    </tr>
    <tr>
      <td><code>|</code></td>
      <td>XOR</td>
      <td>a | b</td>
    </tr>
    <tr>
      <td><code>&lt;</code></td>
      <td>Logical less than</td>
      <td>a &lt; b</td>
    </tr>
    <tr>
      <td><code>&gt;</code></td>
      <td>Logical greater than</td>
      <td>a &gt; b</td>
    </tr>
    <tr>
      <td><code>==</code></td>
      <td>Logical equal to</td>
      <td>a == b</td>
    </tr>
    <tr>
      <td><code>!=</code></td>
      <td>Logical not equal to</td>
      <td>a != b</td>
    </tr>
    <tr>
      <td><code>?:</code></td>
      <td>ternary operator</td>
    </tr>
  </tbody>
</table>

<h2 id="delimiters">Delimiters</h2>

<p>These are ASCII characters or group of two characters used to separate identifiers or literals. Parenthesis can group elements together in collections or complex expressions.
</p>

<table class="table table-bordered table-striped table-dark" >
<thead>
<tr>
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>:</td>
<td>define type</td>
</tr>
<tr>
<td>;</td>
<td>statement separator, define array element type</td>
</tr>
<tr>
<td>,</td>
<td>enumeration</td>
</tr>
<tr>
<td>.</td>
<td>dot operator or decimal separator</td>
</tr>
<tr>
<td>\</td>
<td>string continuation or escape code</td>
</tr>
<tr>
<td>-&gt;</td>
<td>define result type</td>
</tr>
<tr>
<td>&gt;</td>
<td>relation operator: greater then</td>
</tr>
<tr>
<td>&lt;</td>
<td>relation operator: less then</td>
</tr>
<tr>
<td>//</td>
<td>single line comment (can be used at start of line or end of line after ";"</td>
</tr>
<tr>
<td>/*...*/</td>
<td>block comment. Other variations: /** .... */ or /*! .... */ each with slightly different purpose.</td>
</tr>
<tr>
<td>&amp;</td>
<td>borrow</td>
</tr>
<tr>
<td>*</td>
<td>raw pointer</td>
</tr>
<tr>
<td>..</td>
<td>range of numbers or update operator for struct literals</td>
</tr>
<tr>
<td>-&gt;</td>
<td>define result type of a function</td>
</tr>
<tr>
<td>@</td>
<td>pattern bindings</td>
</tr>
<tr>
<td>_</td>
<td>ignored</td>
</tr>
<tr>
<td>?</td>
<td>error propagation symbol</td>
</tr>
<tr>
<td>=&gt;</td>
<td>used in match patterns</td>
</tr>
<tr>
<td>...</td>
<td>inclusive range pattern</td>
</tr>
<tr>
<td>[...]</td>
<td>array literal, vector literal</td>
</tr>
<tr>
<td>{...}</td>
<td>block of code, struct literal, interpolation placeholder</td>
</tr>
<tr>
<td>(...)</td>
<td>tuple, expression, parameters</td>
</tr>
<tr>
<td>&lt;...&gt;</td>
<td>declare generic data types</td>
</tr>
<tr>
<td>#</td>
<td>meta (compiler directive)</td>
</tr>
<tr>
<td>$</td>
<td>macro substitution</td>
</tr>
<tr>
<td>::</td>
<td>file based scoping operator similar to "."</td>
</tr>
<tr>
<td>m!</td>
<td>macro notation for example: print!(). It is also used as logical operator. Do not confuse the two.</td>
</tr>
<tr>
<td>'...'</td>
<td>character literal</td>
</tr>
<tr>
<td>"..."</td>
<td>delimiters for string literal</td>
</tr>
</tbody>
</table>

<h2 id="keywords">Keywords</h2>

<p>
  In the Rust programming language, there are a number of reserved keywords that cannot be used as identifiers. Keywords are part of the syntax and have special meaning in the language. This table lists all of the reserved keywords in Rust along with their descriptions.
</p>

<table class="table table-bordered table-striped table-dark" >
<thead>
<tr>
  <th>Keyword</th>
  <th>Description</th>
</tr>
</thead>

<tbody>
<tr>
  <td>as</td>
  <td>Used for type casting or renaming imports in modules</td>
</tr>
<tr>
  <td>break</td>
  <td>Used to exit a loop or switch statement</td>
</tr>
<tr>
  <td>const</td>
  <td>Used to define a constant value</td>
</tr>
<tr>
  <td>continue</td>
  <td>Used to skip the current iteration of a loop</td>
</tr>
<tr>
  <td>crate</td>
  <td>Used to specify a crate root module in a codebase</td>
</tr>
<tr>
  <td>else</td>
  <td>Used to provide an alternate path in an if statement</td>
</tr>
<tr>
  <td>enum</td>
  <td>Used to define an enumeration</td>
</tr>
<tr>
  <td>extern</td>
  <td>Used to indicate an external item or linkage</td>
</tr>
<tr>
  <td>false</td>
  <td>Boolean value indicating false</td>
</tr>
<tr>
  <td>fn</td>
  <td>Used to define a function or closure</td>
</tr>
<tr>
  <td>for</td>
  <td>Used to iterate over collections or ranges</td>
</tr>
<tr>
  <td>if</td>
  <td>Used to conditionally execute code</td>
</tr>
<tr>
  <td>impl</td>
  <td>Used to implement traits or methods for a type</td>
</tr>
<tr>
  <td>in</td>
  <td>Used to test if a value is contained in a collection</td>
</tr>
<tr>
  <td>let</td>
  <td>Used to bind a value to a variable</td>
</tr>
<tr>
  <td>loop</td>
  <td>Used to repeatedly execute a block of code until a condition is met</td>
</tr>
<tr>
  <td>match</td>
  <td>Used for pattern matching with an expression</td>
</tr>
<tr>
  <td>mod</td>
  <td>Used to define a module</td>
</tr>
<tr>
  <td>move</td>
  <td>Used to move ownership of variables between scopes or closures</td>
</tr>
<tr>
  <td>mut</td>
  <td>Used to define a mutable variable</td>
</tr>
<tr>
  <td>pub</td>
  <td>Used to denote a public visibility modifier</td>
</tr>
<tr>
  <td>ref</td>
  <td>Used to introduce a reference to a value</td>
</tr>
<tr>
  <td>return</td>
  <td>Used to return a value from a function or closure</td>
</tr>
<tr>
  <td>self</td>
  <td>Used to refer to the current module or implementation</td>
</tr>
<tr>
  <td>static</td>
  <td>Used to denote a static lifetime or mutable global variable</td>
</tr>
<tr>
  <td>struct</td>
  <td>Used to define a structure</td>
</tr>
<tr>
  <td>super</td>
  <td>Used to refer to the parent module or implementation</td>
</tr>
<tr>
  <td>true</td>
  <td>Boolean value indicating true</td>
</tr>
<tr>
  <td>trait</td>
  <td>Used to define a trait or interface</td>
</tr>
<tr>
  <td>type</td>
  <td>Used to define a type alias or synonym</td>
</tr>
<tr>
  <td>unsafe</td>
  <td>Used to denote unsafe code or operations</td>
</tr>
<tr>
  <td>use</td>
  <td>Used to introduce a path to a module or item</td>
</tr>
<tr>
  <td>where</td>
  <td>Used in function signatures to specify trait bounds on generic types</td>
</tr>
<tr>
  <td>while</td>
  <td>Used to repeatedly execute a block of code while a condition is met</td>
</tr>
</tbody>
</table>

<div class="alert alert-warning"><b>Warning: </b>You should avoid using these keywords as identifiers or file names. Reserved keywords are used in language statements. You do not have to memorize all of them right now. You will learn these in the future from our tutorial.</div>

<hr>
<p><b>Read next:</b>
<a href="types.html">Data Types</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>