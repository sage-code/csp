<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Learn how to debug JavaScript using colsole.log().">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="javascript, js, programming, tutorial">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>JS Errors</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="https://sagecode.net/prism.css">
  <script src="https://sagecode.net/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">

<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"></a>
    </div>
    <div class="col bottom-right">
        <a href="index.html#js-bookmark" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>

<h2>JavaScript Errors</h2>

<div class="alert alert-secondary shadow-sm">
During development, you run your JavaScript code often to find errors. This process is called debugging. A "bug" in programming is not an insect but an unexpected situation called "error" or "bug". To find them you need to test your code multiple times.
</div>

<h4>Page bookmarks:</h4>
<hr>
<nav><ul>
<li><a href="#errors">Errors & Bugs</a></li>
<li><a href="#console">Using console</a></li>
<li><a href="#debug">Debug Tools</a></li>
<li><a href="#practice">Best Practice</a></li>
<li><a href="#proactive">Proactive Programming</a></li>
<li><a href="#exceptions">Exceptions</a></li>
</ul></nav>
<hr>

<h2 id="errors">Errors & Bugs</h2>

<p><b>Logical errors:&nbsp;</b>The most common technique to find JavaScript errors is to introduce a "spy". This is a line of code that display a message to console that you can investigate.If the message produce unexpected output, you are about to find an unexpected logical error.
</p>

<p><b>Syntax errors:&nbsp;</b>These errors are produced during runtime. Your code execute until a syntax error is encountered. Then the program is stopping its execution and you can read a usually red message about the error. For these kind of errors you do not need to create a "spy" statement.</p>

<p><b>Step by step:&nbsp;</b>Sometimes the error is difficult to find. The last resort is to run a script step by step. This require to set a "breakpoint". This is not a script element it is a location (a statement number) that is flagged by the IDE with a red dot. When your script reach that specific point, it will suspend.</p>

<p><b>Inspection:&nbsp;</b>
You can inspect values of variables (in scope) using using special window that can show the objects and the values from memory. After the inspection you can press a button and the script can resume running one step at a time or it can run up to next "breakpoint" depending on the button you use.</p>

<h2 id="console">Using Console</h2>

<p>The console in JavaScript is a powerful tool that can be used to debug your code, log information, and interact with the browser. It is a property of the window object, and it provides a number of methods that can be used to output text, objects, and other data to the browser console.</p>

<table class="table table-bordered table-striped table-dark">
  <tr>
  <th>Method</th> 
  <th>Description</th> 
  </tr>
  <tr>
  <td>console.log()</td>
  <td>Writes a message to the console.</td>  
  </tr>
   <tr>
  <td>console.info()</td>
  <td>Writes an informational message to the console.</td>
  </tr>
  <tr>
  <td>console.warn()</td> 
  <td>Writes a warning message to the console.</td>
  </tr>
  <tr>
  <td>console.error()</td>
  <td>Writes an error message to the console.</td>
  </tr>
  <tr>
  <td>console.clear()</td>
  <td>Clears the console.</td>
  </tr>
  <tr>
  <td>console.assert()</td> 
  <td>Tests if an expression evaluates to true.</td>
  </tr>  
  <tr>
  <td>console.count()</td>
  <td>Increments a counter, printing the counter name and value.</td>
  </tr>
  <tr>
  <td>console.time() / console.timeEnd()</td>
  <td>Measures the time taken between calling time and timeEnd.</td>
  </tr>
</table>

<h4>Example:</h4>

<pre><code class="language-javascript line-numbers">/*spy demo*/
{ let x = 5, y = 10;
  console.log(x,y) //first spy
  x++
  y++
  console.log(x,y) //second spy
  x++
  y++
  /* better output */
  console.log("x = ",x)
  console.log("y = ",y)
}
</code></pre>

<h2 id="debug">Debug Tools</h2>

<p>You can debug JavaScript in Browser. Your script is preloaded when you visit a web page.If your code is stored as a script file, you can load the script using browser and debug it by `following these steps:
</p>

<h3>Chrome debug in console.</h3>

<ol>
<li>Hit the F12 key or Ctrl+Shift+I;</li>
<li>Select the Scripts , or Sources tab;</li>
<li>Select "js/test.js" script from the tree;</li>
<li>Add a breakpoints by clicking on the line number;</li>
<li>Click this link to execute: <a href="javascript:test();">test()</a></li>
<li>Use F11 to run step by step.</li>
<li>Click Console tab to see the messages.</li>
</ol>
<hr>
<div class="text-center">
    <img src="img/debug.jpg" class="image img-fluid protect rounded shadow" alt="Responsive Image">
    <p>Chrome Console Source</p>
</div>

<hr>

<h3>Firefox debug in console.</h3>

<ol>
<li>Hit the F12 key or Ctrl+Shift+I;</li>
<li>Select the Debugger tab;</li>
<li>Select "js/test.js" script from the tree;</li>
<li>Add a breakpoints by clicking on the line number;</li>
<li>Click this link to execute: <a href="javascript:test();">test()</a></li>
<li>Use F11 to run step by step.</li>
<li>Click Console tab to see the messages.</li>
</ol>

<div class="text-center">
    <img src="img/debugger.jpg" class="image img-fluid protect rounded shadow" alt="Responsive Image">
    <p>Firefox Console Debugger</p>
</div>

<section>
  <h2>Errors and Pitfalls</h2>

  <ul>
  <li>Type Coercion - Implicit type conversions that can sometimes cause unexpected results.</li> 
  <li>Hoisting - Var variables are hoisted to the top of their scope, which can cause issues.</li>
  <li>Forgetting semicolons - Can cause syntax errors when JavaScript infers a newline as an expression end.</li>  
  <li>Missing comma in object literal - Forgotten commas between object properties also cause syntax errors.</li>
  <li>Undefined is not a function - Calling undefined variables as functions is a common mistake.</li>
  </ul>
</section>

<section>
  <h2 id="practice">Best Practices</h2>
  <ul>
   <li>Use strict mode - It catches common coding mistakes and 'unsafe' actions.</li>
   <li>Initialize variables - Define all variables before use to avoid undefined errors.</li>
   <li>Use === over == - Strict comparison avoids type coercion surprises.</li>
   <li>Use const over let - Const by default avoids reassignment bugs.</li>  
   <li>Avoid side effects - Side effects in functions make debugging harder.</li>
   <li>Catch errors - Catch errors gracefully instead of crashing the program.</li> 
   <li>Modularize code - Splitting code into modules limits scope and dependencies.</li>
  </ul>
 </section>

 <section>
 <h2 id="proactive">Proactive Programming</h2>

 <p>Instead of waiting for error to happen, a good developer can prevent the situation by checking some conditions before performing the computations that can fail. This is called proactive error handling and is the best method to avoid probable errors.</p>
 
 <h3>Use Type Checking</h3>
 <pre><code class="language-js">
 function add(x, y) {
 // Type check inputs 
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new TypeError('The arguments must be numbers!');
  }
  
  return x + y;
 }   
 </code></pre>
 
 <h3>Use Default Parameters</h3>
 <pre><code class="language-js">
 function add(x, y=0) {
  return x + y;
 }
 </code></pre>
 
<h3>Using Assert()</h3>

<p>The assert() method helps avoid errors by checking if a condition is true. If not, it throws an AssertionError.</p>

<pre><code class="language-js">
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed!'); 
  }
}

function square(n) {
  assert(typeof n === 'number', 'n must be a number!');
  
  return n * n;
}

square(4);  // Returns 16
square('2'); // Throws Error
</code></pre> 

<p>We can also provide a custom error message:</p>

<pre><code class="language-js">
function divide(a, b) {
  assert(b !== 0, 'Attempted to divide by zero!');
  
  return a / b;  
}

divide(4, 2);  // Returns 2
divide(4, 0);  // Throws custom Error
</code></pre>
</section>

<section>

<h2 id="exceptions">Exceptions</h2>

<div class="alert alert-secondary shadow-sm">
Exceptions are abnormal situations that can cause a computer program to malfunction, produce unpredictable or incorrect results.In this case the application should report an error message and interrupt itself or at least verify the situation and decide to stop or continue.
</div>

<h3>Producing exceptions</h3>
<p>An exception can be created by the system when a statement can not be executed properly. You can also create exceptions on purpose. Usually you check a condition and decide before producing an exception. Most elegant is to produce an Error object as exception, but JavaScript enable you to produce an exception using any value. The example below will use keyword: throw to create an exception.</p>

<h4>Example:</h4>

<pre><code class="language-javascript line-numbers">// create exception object
throw new Error("You got an exception")
// create exception with a string object
throw "You get an exception!"
// create exception with a number object
throw -1</code></pre>

<p><b>Homework:</b>&nbsp;Run the example above. This example will stop on first statement, but you can comment statements one by one to check the effect of each individual case. The script will stop and you get an error message similar to this:</p>

<pre><code class="language-output">error: Uncaught -1</code></pre>

<h3>Resolving exceptions</h3>

<p>Unresolved exceptions cause script to stop and produce an error to console, but your web-page will usually continue working with defects. To avoid these defects you must do proactive programming. This means you must check conditions and handle errors to avoid "Uncaught Exceptions".</p>

<p>For resolving exception you can use a special "control flow" statement that is called "try". It is a multi-block statement with several regions: The main block start after "try" keyword. You can use "catch blocks" to resolve several potential errors and "finally" block to execute after error is resolved.</p>


<h4>Example:</h4>

<pre><code class="language-javascript line-numbers">try {
   throw 'error';
}
catch (e) {
   console.error(e);
}
finally {
   console.log('done')
}</code></pre>

<h4>Notes:</h4>

<p>If you use: console.error() instead of console.log, the console will probably print your error message with red color. You can use a function to do something with the error. Usually you log the error and continue program execution. Handler</p>

<p>The catch statement has a handler that is created automatically. You can specify this handler name in parenthesis after catch keyword. In our case the exception handler is: e. Handler type depends on your throw statement. If you create an Error object the handler will represent the object. In our case, e is of type 'string'.</p>

<h3>Conditional Catch</h3>
<p>You can create different catch statements using a conditional. Notice though this is very new and it may bot be supported by many engines. Check with your team before you use this syntax.</p>
<h4>Pattern:</h4>
<p>Next is "pseudo code" fragment to demonstrate "conditional catch" design pattern.</p>

<pre><code class="language-javascript line-numbers">try {
   myroutine(); // may throw three types of exceptions
} catch (e if e instanceof TypeError) {
 // statements to handle TypeError exceptions
} catch (e if e instanceof RangeError) {
 // statements to handle RangeError exceptions
} catch (e if e instanceof EvalError) {
 // statements to handle EvalError exceptions
} catch (e) {
 // statements to handle any unspecified exceptions
 logMyErrors(e); // pass exception object to error handler
}</code></pre>

<h3>Finally Block</h3>
<p>The finally block is executed no matter what. In this block you can close a resource or log a message. When in this block you do not know if there was an error or not, but this code is guaranteed to be executed in any case.</p>

<h4>Pattern:</h4>
<p>Next pattern demonstrate how to handle resources using try &ndash; finally block.</p>

<pre><code class="language-javascript line-numbers">open_resource();
try {
   use_resource(my_data);
}
finally {
   close_resource(); // always close the resource
}</code></pre>

<h3>JavaScript Error</h3>
<p>The Error instance must be created using "new" operator like any other object. You can create an exception object and "throw" the object later once or several times, depending on your programming logic. Also you can create the object anonymously and give it a name later using "catch".</p>

<h4>Example:</h4>

<pre><code class="language-javascript line-numbers">// named exception
let exception = new Error('my exception');
// create a named exception
try {
   throw exception
}
catch (e) {
   if (e instanceof Error) {
      console.error(e.message);
   } else {
      console.log("unexpected exception");
   }
}
// your program can continue
console.log("continue program")
</code></pre>


<p>To learn more about Error object read the reference:&nbsp;
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error"
   target="_blank" rel="nofollow noopener noreferrer">MDN Error</a></p>

<hr>

<div class="alert alert-warning"><b>Caution:&nbsp;</b>Next example demonstrate a common error in JavaScript: Using relation operators with two objects will compare object references and not object attributes or values they represent. Read the example and wander how is this possible. JavaScript is not perfect and sometimes difficult to explain.
</div>

<pre><code class="language-javascript line-numbers">/* create non null Boolean object */
var a = Boolean(false); // boolean
var b = new Boolean(false); // object
console.log(a === false) //true (expected)
console.log(b === false) //false (unexpected)
// a is "boolean" works as expected
if (a)
  console.log("a is true");
else
  console.log("a is false"); //expected
// b is "object" works in unexpected way
if (b)
  console.log("b is true"); // unexpected
else
 console.log("b is false");
</code></pre>


<hr>

<p><b>Read next:</b>
<a href="website.html">Website</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>



</div>


</body>
</html>