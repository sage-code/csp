<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Introductory tutorial for Julia programming language.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="julia, language, syntax, programming, tutorial">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Julia Syntax</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="https://sagecode.net/prism.css">
  <script src="https://sagecode.net/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"></a>
    </div>  
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>

<h1>Julia Syntax</h1>

<div class="alert alert-secondary shadow-sm">The syntax is minimalist and is based on English keywords. Therefore Julia is very readable compared to curly braced languages. You can learn Julia to proficient level in less then one week as your first computer language.
</div>

<p>Julia language has a very polished syntax. It eliminate annoying elements found in other languages while implementing most of the important features. Having a simplified syntax matter. This is one of the simplistic language out there that have significant performance and power. This is one of the reason we recommend Julia to beginners.</p>

<h2>Syntax characteristics</h2>
  
<ul>
<li>Full English names for keywords;</li>
<li>Optional ";" at the end of statement;</li>
<li>Long expressions can span multiple lines;</li>
<li>Block of code is terminated using "end";</li>
<li>Type inference makes declarations unnecessary;</li>
<li>The indentation and the end of line are irrelevant;</li>
<li>Julia has support Unicode operators like: &le; &ge; &ne;;</li>
<li>Strings are enclosed in double quotes "string";</li>
<li>Julia operators are functions;</li>
</ul>

<p><b>Example of program:</b></p>
<pre><code class="language-julia line-numbers"># first julia program
print("Hello World")
</code></pre>


<h2>Comments</h2>

<p>Line comments is starting with symbol "#" exactly like in Python. Nested comments are possible in Julia. To create a multi-line comment in Julia we use two symbols: #= &hellip;. =#. That is unconventional but has a logic behind. We can create a separator line like this:</p>

<pre><code class="language-julia line-numbers">
#================================#
# This is a comment demo
#================================#
</code></pre>

<h2>Keywords</h2>

<p>Next I will list several Julia keywords in logical order but not all of them. You may encounter other keywords in practice. I will try to add more keywords here when I fully understand them. Remember this article is just an introduction tutorial not a reference document.</p>
<div>
<table class="table table-striped table-bordered table-dark">
<thead>
<tr>
<th>Keyword</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td>The constant true is a Boolean value</td>
</tr>
<tr>
<td>false</td>
<td>The constant false is a Boolean value</td>
</tr>
<tr>
<td>maybe</td>
<td>Not a keyword ðŸ™‚ just teasing you</td>
</tr>
<tr>
<td>constant</td>
<td>Define a constant usually a global</td>
</tr>
<tr>
<td>global</td>
<td>Used in local scope to show that a variable is not local</td>
</tr>
<tr>
<td>local</td>
<td>Used in local scope to force a variable to be local and hide a global variable</td>
</tr>
<tr>
<td>begin</td>
<td>Mark the beginning of a compound expression block "begin &hellip; end"</td>
</tr>
<tr>
<td>let</td>
<td>Mark the beginning of a let block: "let &hellip; end"</td>
</tr>
<tr>
<td>end</td>
<td>Mark the end of a block, function or module</td>
</tr>
<tr>
<td> function</td>
<td> Create a function</td>
</tr>
<tr>
<td>module</td>
<td>Create a module</td>
</tr>
<tr>
<td>return</td>
<td>Create an exit point from a function and return a result</td>
</tr>
<tr>
<td>import</td>
<td>Import into a module public members from another module</td>
</tr>
<tr>
<td>export</td>
<td>Export module public members to be imported into another module</td>
</tr>
<tr>
<td>if</td>
<td>Decision statement</td>
</tr>
<tr>
<td>else</td>
<td>Alternative block for false condition</td>
</tr>
<tr>
<td>elseif</td>
<td>Alternative block for second condition</td>
</tr>
<tr>
<td>while</td>
<td>Start a while loop "while &hellip; end"</td>
</tr>
<tr>
<td>for</td>
<td>Start a for loop: "for &hellip; in &hellip; end"</td>
</tr>
<tr>
<td>in</td>
<td>Used with for to iterate over a range or collection</td>
</tr>
<tr>
<td>break</td>
<td>Stop a while or a for loop</td>
</tr>
<tr>
<td>continue</td>
<td>Shortcut a loop and continue with next iteration</td>
</tr>
<tr>
<td>print</td>
<td>Print a message to console</td>
</tr>
<tr>
<td>println</td>
<td>Print a message to console and add end of line</td>
</tr>
<tr>
<td>try</td>
<td>Start a block of code that may rise exceptions</td>
</tr>
<tr>
<td>catch</td>
<td>Start exception handling block</td>
</tr>
<tr>
<td>finally</td>
<td>Is the final part that execute not matter what for a try block</td>
</tr>
<tr>
<td>throw()</td>
<td>This is a standard function to create an exception</td>
</tr>
<tr>
<td>error()</td>
<td>Also create an exception of type ErrorException</td>
</tr>
<tr>
<td>abstract</td>
<td>Define an abstract type</td>
</tr>
<tr>
<td>primitive</td>
<td>Used to create a primitive type</td>
</tr>
<tr>
<td>type</td>
<td>Used with abstract or primitive keyword to create a type</td>
</tr>
<tr>
<td>struct</td>
<td>Create a structure like a record (immutable)</td>
</tr>
<tr>
<td>mutable</td>
<td>Used with struct to create a mutable struct</td>
</tr>
<tr>
<td>union</td>
<td>Used to create a union type</td>
</tr>
<tr>
<td>typeof()</td>
<td>This is a function used to display type information about a variable</td>
</tr>
<tr>
<td>isa()</td>
<td>A function that return true or false about type of a variable</td>
</tr>
<tr>
<td>supertype()</td>
<td>Extract the supe-type information for a type</td>
</tr>
<tr>
<td>Nullable{}</td>
<td>Create a null-able type</td>
</tr>
<tr>
<td>isnull()</td>
<td>Check if a null-able type is null</td>
</tr>
<tr>
<td>macro</td>
<td>block of code execute when code is parsed (used to generate code), invoke macro with @ operator.</td>
</tr>
<tr>
<td>quote</td>
<td>expression that span multiple lines used as alternative to quote operator ":"</td>
</tr>
<tr>
<td>eval()</td>
<td>used in meta-programming to evaluate a string expression</td>
</tr>
</tbody>
</table>
</div>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="types.html">Type System</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>