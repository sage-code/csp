<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
    <meta charset="utf-8">
    <meta name="description" content="Template page for tutorials.">
    <meta name="author" content="Elucian Moise">
    <meta name="keywords" content="language, syntax, programming, tutorial">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Website title -->
    <title>Tutorial</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <!-- Icon -->
    <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">
    <!-- Prism Highlighter -->
    <link rel="stylesheet" href="../prism.css">
    <script src="../prism.js"></script>
    <!-- custom css -->
    <link rel="stylesheet" href="https://sagecode.net/sage.css">
    </head>
<body>

<div class="container">

<!-- header -->
<header class="row">
      <div class="col">
          <a href="https://sagecode.net"><img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"></a>
      </div>
      <div class="col  bottom-right">
          <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
      </div>
</header><hr>

<h2>Expressions</h2>

<div class="alert alert-secondary shadow-sm">
Page description. To be replaced!
</div>

<h2>Variables</h2>

<p>When you wish to declare a variable in Julia you use Duck typing. For this you use a type literal to provide enough information to the compiler to derive the type. Once the type is established you can use the variable in expressions. In Julia evening is an expression.</p>

<pre><code class="language-julia">message = "Hello World"</code></pre>

<p>The message is a string variable having value "Hello World". Observe that we do not use keyword "var" like in JavaScript or other languages. Also in Julia a variable can be re-purpose. The type can be changed when the variable is assigned using "=" symbol. A new value of a different type can be assigned.</p>


<hr>

<h2>Arithmetic Operators</h2>

<p>The following operators are supported on all primitive numeric types:</p>

<table class="table table-striped table-bordered table-dark">
  <tbody>
  <tr>
    <th>Expression</th>
    <th>Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>+x</td>
    <td>unary plus</td>
    <td>the identity operation</td>
  </tr>
  <tr>
    <td>-x</td>
    <td>unary minus</td>
    <td>maps values to their additive inverses</td>
  </tr>
  <tr>
    <td>x + y</td>
    <td>binary plus</td>
    <td>performs addition</td>
  </tr>
  <tr>
    <td>x &ndash; y</td>
    <td>binary minus</td>
    <td>performs subtraction</td>
  </tr>
  <tr>
    <td>x * y</td>
    <td>times</td>
    <td>performs multiplication</td>
  </tr>
  <tr>
    <td>x / y</td>
    <td>divide</td>
    <td>performs division</td>
  </tr>
  <tr>
    <td>x \ y</td>
    <td>inverse divide</td>
    <td>equivalent to y / x</td>
  </tr>
  <tr>
    <td>x ^ y</td>
    <td>power</td>
    <td>raises x to the y power</td>
  </tr>
  <tr>
    <td>x % y</td>
    <td>remainder</td>
    <td>equivalent to rem(x,y)</td>
  </tr>
  </tbody>
</table>


  <h2>Bitwise Operators</h2>

  <p>These operators are performing fast low-level operations on bits on native integer types.</p>
  <div>
  <table class="table table-striped table-bordered table-dark">
  <thead>
  <tr>
  <th>Expression</th>
  <th>Name</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>~x</td>
  <td>bitwise not</td>
  </tr>
  <tr>
  <td>x &amp; y</td>
  <td>bitwise and</td>
  </tr>
  <tr>
  <td>x | y</td>
  <td>bitwise or</td>
  </tr>
  <tr>
  <td>x $ y</td>
  <td>bitwise xor exclusive or: (deprecated)</td>
  </tr>
  <tr>
  <td>x &gt;&gt;&gt; y</td>
  <td>logical shift right</td>
  </tr>
  <tr>
  <td>x &gt;&gt; y</td>
  <td>arithmetic shift right</td>
  </tr>
  <tr>
  <td>x &lt;&lt; y</td>
  <td>logical/arithmetic shift left</td>
  </tr>
  </tbody>
  </table>
</div>

<h2>Modifiers</h2>

<p>Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing equal symbol "=" immediately after the operator like this:</p>

<pre><code class="language-julia">+=, -=, *=, /=, ^=, %=, ~=, &amp;=, $=, &gt;&gt;=, &lt;&lt;=</code></pre>

<div class="alert alert-warning"><b>Note:</b> The update operator is not in-place operator like it is in C. What it means is the variable on the left side can change its type and value in the same time. So these operators are actually version of assign operator.</div>

<pre><code class="language-julia">x *= 2 #is equivalent to x = x * 2</code></pre>

<h2>Comparison Operators</h2>

<p>A numeric comparison can be used into a conditional expression. It has a result of type Boolean that is true or false.</p>
<div>
<table class="table table-striped table-bordered table-dark">
<tbody>
<tr>
<th>Operator</th>
<th>Name</th>
</tr>
<tr>
<td>==</td>
<td>equality</td>
</tr>
<tr>
<td>!=, &ne;</td>
<td>inequality (disjunctive)</td>
</tr>
<tr>
<td>&lt;</td>
<td>less than</td>
</tr>
<tr>
<td>&lt;=, &le;</td>
<td>less than or equal to</td>
</tr>
<tr>
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr>
<td>&gt;=, &ge;</td>
<td>greater than or equal to</td>
</tr>
</tbody>
</table>
</div>

<h2>Logical Operators</h2>

<p>Logical operators and comparison operators can be combined to create logical expressions that evaluate to true or false.</p>
<div>
<table class="table table-striped table-bordered table-dark">
<tbody>
<tr>
<th>Operator</th>
<th>Name</th>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>AND</td>
</tr>
<tr>
<td>||</td>
<td>OR</td>
</tr>
<tr>
<td>!</td>
<td>NOT</td>
</tr>
</tbody>
</table>
</div>

<h2>Table of Truth</h2>

<p>In Julia Boolean values are: true, false. We cant use 1 and 0 like in other languages. Next is a combination of possible values for A, B and the result of several basic expressions. A&amp;&amp;B meaning A and B, A||B meaning A or B then !A meaning negation of A an then !B meaning negation of B. If you are not familiar with these expressions then you need to look into Boolean algebra.</p>
<div>
<table class="table table-striped table-bordered table-dark">
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A&amp;&amp;B</th>
<th>A||B</th>
<th>!A</th>
<th>!B</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>0</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
</div>

<h2>Punctuation</h2>

<p>In the next table we present a mingle of symbols used by Julia for different purposes. Some are operators but some are just conventions.</p>
<div>
<table class="table table-striped table-bordered table-dark">
<thead>
<tr>
<th>symbol</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>@m</td>
<td>invoke macro m; followed by space-separated expressions</td>
</tr>
<tr>
<td>!</td>
<td>prefix "not" operator</td>
</tr>
<tr>
<td>a!( )</td>
<td>at the end of a function name, ! indicates that a function modifies its argument(s)</td>
</tr>
<tr>
<td>#</td>
<td>begin single line comment</td>
</tr>
<tr>
<td>#=</td>
<td>begin multi-line comment (these are nestable)</td>
</tr>
<tr>
<td>=#</td>
<td>end multi-line comment</td>
</tr>
<tr>
<td>$</td>
<td>string and expression interpolation</td>
</tr>
<tr>
<td>%</td>
<td>remainder operator</td>
</tr>
<tr>
<td>^</td>
<td>exponent operator</td>
</tr>
<tr>
<td>&amp;</td>
<td>bitwise and</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>short-circuiting Boolean "and"</td>
</tr>
<tr>
<td>|</td>
<td>bitwise or</td>
</tr>
<tr>
<td>||</td>
<td>short-circuiting Boolean "or"</td>
</tr>
<tr>
<td>⊻</td>
<td>bitwise xor operator (use to be $ but I think it was changed)</td>
</tr>
<tr>
<td>*</td>
<td>number multiplication, matrix multiplication, string concatenation</td>
</tr>
<tr>
<td>()</td>
<td>the empty tuple</td>
</tr>
<tr>
<td>~</td>
<td>bitwise "not" operator</td>
</tr>
<tr>
<td>\</td>
<td>backslash operator</td>
</tr>
<tr>
<td>&lsquo;</td>
<td>complex transpose operator Aᴴ</td>
</tr>
<tr>
<td>a[]</td>
<td>array indexing</td>
</tr>
<tr>
<td>[,]</td>
<td>vertical concatenation</td>
</tr>
<tr>
<td>[;]</td>
<td>also vertical concatenation</td>
</tr>
<tr>
<td>[ ]</td>
<td>with space-separated expressions, horizontal concatenation</td>
</tr>
<tr>
<td>T{ }</td>
<td>parametric type instantiation</td>
</tr>
<tr>
<td>;</td>
<td>statement separator</td>
</tr>
<tr>
<td>,</td>
<td>separate function arguments or tuple components</td>
</tr>
<tr>
<td>?</td>
<td>3-argument conditional operator (conditional ? if_true : if_false)</td>
</tr>
<tr>
<td>""</td>
<td>delimit string literals</td>
</tr>
<tr>
<td>"</td>
<td>delimit character literals</td>
</tr>
<tr>
<td>` `</td>
<td>delimit external process (command) specifications</td>
</tr>
<tr>
<td>&hellip;</td>
<td>splice arguments into a function call or declare a varargs function or type</td>
</tr>
<tr>
<td>.</td>
<td>access named fields in objects/modules</td>
</tr>
<tr>
<td>a:b</td>
<td>range a, a+1, a+2, &hellip;, b</td>
</tr>
<tr>
<td>a:s:b</td>
<td>range a, a+s, a+2s, &hellip;, b</td>
</tr>
<tr>
<td>:</td>
<td>index an entire dimension (1:end)</td>
</tr>
<tr>
<td>::</td>
<td>type annotation, depending on context</td>
</tr>
<tr>
<td>: ( )</td>
<td>quoted expression</td>
</tr>
<tr>
<td>:a</td>
<td>symbol a</td>
</tr>
<tr>
<td>&lt;:</td>
<td>sub-type operator</td>
</tr>
<tr>
<td>&gt;:</td>
<td>supertype operator (reverse of subtype operator)</td>
</tr>
<tr>
<td>===</td>
<td>equal comparison operator</td>
</tr>
</tbody>
</table>
</div>

<!-- work in progress-->

  <hr>
  
  <p><b>Read next:</b>
  <a href="control.html">Control Flow</a></p>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-copyright text-center"></div>
  </footer>
  </div>
  </body>
  </html>